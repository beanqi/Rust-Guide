# 第十三章 函数、宏以及闭包（匿名函数）

在 Rust 中，除了标准的函数之外，宏（Macros）和闭包（Closures）也是极其重要的代码组织与复用工具。函数提供了最基础的逻辑封装，宏赋予了我们在编译期生成代码的强大元编程能力，而闭包则灵活地支持了上下文捕获和函数式编程风格。本章将深入探讨这三者的工作原理、使用方法及其异同。

---

## 1. 函数 (Functions)

函数是 Rust 代码中最基本的构建块。它们具有显式的类型签名，不仅是逻辑封装的单元，也是大多数 API 的边界。

### 1.1 基本特性

- **显式类型**：参数类型和返回值类型必须明确声明。
- **环境隔离**：普通函数无法捕获定义时所在环境的变量（不仅是全局变量，也包括局部变量），它们只能操作传入的参数和全局静态变量。

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

---

## 2. 宏 (Macros)

Rust 的宏与 C 语言中的宏截然不同。Rust 的宏不仅是文本替换，而是基于**标记树（Token Tree）**的元编程工具。宏在编译的早期阶段展开，生成的代码随后才会被编译器进行常规的类型检查和编译。

### 2.1 为什么要使用宏？

1.  **元编程（Metaprogramming）**：宏可以生成代码，减少重复代码（DRY）。
2.  **可变参数**：Rust 函数不支持可变数量的参数，但宏可以。例如 `println!` 和 `vec!`。
3.  **DSL 构建**：宏允许你定义特定的语法结构。

### 2.2 声明式宏 (Declarative Macros)

最常见的宏类型，使用 `macro_rules!` 定义。它们类似于 match 表达式，通过模式匹配来决定如何替换代码。

```rust
macro_rules! say_hello {
    () => {
        println!("Hello!");
    };
    ($name:expr) => {
        println!("Hello, {}!", $name);
    };
}

fn main() {
    say_hello!();        // 匹配第一条规则
    say_hello!("Rust");  // 匹配第二条规则
}
```

### 2.3 过程宏 (Procedural Macros)

过程宏更像是一个函数，它接受代码作为输入（TokenStream），操作它，并产生新的代码作为输出。主要分为三种：
- **自定义派生（Custom Derive）**：`#[derive(CustomTrait)]`
- **类属性宏（Attribute-like）**：`#[route(GET, "/")]`
- **类函数宏（Function-like）**：`sql!("SELECT * FROM posts")`

---

## 3. 匿名函数与闭包 (Closures)

闭包（Closure）是可以保存在变量中或作为参数传递给其他函数的**匿名函数**。与普通函数不同，闭包可以**捕获**其定义作用域中的值。

### 3.1 定义与语法

闭包的定义使用 `||` 包含参数，且通常不需要显式标注类型（编译器会自动推断）。

```rust
fn main() {
    let x = 10;
    
    // 定义一个闭包，它捕获了变量 x
    let add_to_x = |num| num + x;
    
    println!("{}", add_to_x(5)); // 输出 15
}
```

### 3.2 捕获环境的方式

闭包捕获环境的方式决定了它实现了哪种 Trait（`Fn`, `FnMut`, `FnOnce`）：

1.  **`Fn` (不可变借用)**：闭包只读取捕获的变量，不修改它们。
2.  **`FnMut` (可变借用)**：闭包会修改捕获的变量。
3.  **`FnOnce` (获取所有权)**：闭包会消费（移动）捕获的变量。

```rust
fn main() {
    let mut count = 0;
    
    // 因为修改了 count，所以是 FnMut
    let mut increment = || {
        count += 1;
        println!("Count: {}", count);
    };
    
    increment();
    increment();
}
```

### 3.3 `move` 关键字

使用 `move` 关键字可以强制闭包获取环境中变量的所有权，这在多线程场景下非常有用。

```rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    
    // 使用 move 将 list 的所有权转移到新线程中
    thread::spawn(move || {
        println!("From thread: {:?}", list);
    }).join().unwrap();
}
```

---

## 4. 对比：函数、宏与闭包

| 特性 | 函数 (Function) | 宏 (Macro) | 闭包 (Closure) |
| :--- | :--- | :--- | :--- |
| **定义方式** | `fn name(args) -> type` | `macro_rules!` 或过程宏 | `\|args\| body` |
| **类型检查** | 显式类型，定义时检查 | 展开后检查 | 类型推断，通常不需要显式标注 |
| **参数数量** | 固定 | **可变** | 固定 |
| **捕获环境** | 不支持 | 不适用（宏在编译期展开） | **支持**（这是其核心特性） |
| **运行时开销** | 极低（直接调用） | 无（编译期展开），但可能增加二进制体积 | 极低（通常会被编译为匿名结构体并内联） |
| **主要用途** | 通用逻辑封装，模块边界 | 代码生成，DSL，可变参数接口 | 迭代器适配，回调，短小逻辑 |

### 4.1 性能差异

- **函数与闭包**：在 Rust 中，闭包通常会被编译为实现了特定 Trait 的匿名结构体。这意味调用闭包通常是**静态分发**的，编译器可以将其内联（Inline）。因此，闭包的性能通常与手写的函数调用一致，没有额外的运行时开销（除非使用了 `Box<dyn Fn>` 进行动态分发）。
- **宏**：宏的代码在编译期生成并展开。虽然这不会带来运行时调用的开销，但过度使用宏会导致生成的二进制文件体积膨胀，且可能增加编译时间。

### 4.2 选择建议

- 如果你需要复用一段逻辑，且不需要捕获环境，首选**函数**。
- 如果你需要一段简短的逻辑作为参数传递（如传给 `.map()` 或 `.filter()`），或者需要捕获上下文变量，使用**闭包**。
- 如果你需要处理可变数量参数，或者需要在编译期自动生成代码（如实现 Trait），使用**宏**。
