# 10. 内部可变性与智能指针

本章围绕两条主线：

- **内部可变性（interior mutability）**：允许你在“只有共享引用（`&T`）”的情况下仍然修改内部状态。
- **智能指针（smart pointer）**：不仅“像指针”，还携带额外语义（所有权、引用计数、线程安全、析构逻辑等），通常通过 `Deref` / `Drop` 等 trait 参与语言体验。

它们看似两块内容，但实践中经常一起出现：例如 `Rc<RefCell<T>>`、`Arc<Mutex<T>>`。

---

## 10.1 为什么要有内部可变性？`Cell`、`RefCell` 解决了什么问题

Rust 的核心规则之一是：

- **要么多个共享借用 `&T`**
- **要么一个可变借用 `&mut T`**

这保证了在编译期就能排除大量数据竞争和别名修改问题。

但现实中有一种非常常见的需求：

> 我想让一个类型的方法签名是 `&self`（因为它对外“看起来是只读的”/需要实现某个 trait），但内部仍然想维护一些状态（缓存、计数器、延迟初始化等）。

这时就会遇到冲突：**接口上必须是 `&self`，但实现上需要修改内部字段**。

内部可变性就是对此的“受控放行”：

- 从类型系统角度，你拿到的是共享引用 `&T`
- 但 `T` 的内部通过特定封装（`Cell`/`RefCell`/`Mutex`/`RwLock` 等）允许修改

### 10.1.1 `Cell<T>`：适合小、可复制的数据

`Cell<T>` 提供的是**“拷贝进/拷贝出”**的内部可变性。它的典型 API：

- `get(&self) -> T`（要求 `T: Copy`）
- `set(&self, value: T)`
- `replace(&self, value: T) -> T`

因为 `get()` 返回 `T` 的拷贝，所以它不能让你拿到 `&T`，也就不会产生“拿着引用同时又修改”的别名问题。

示例：在 `&self` 方法里维护计数器：

```rust
use std::cell::Cell;

#[derive(Debug)]
struct Metrics {
	hits: Cell<u64>,
}

impl Metrics {
	fn new() -> Self {
		Self { hits: Cell::new(0) }
	}

	fn record_hit(&self) {
		let current = self.hits.get();
		self.hits.set(current + 1);
	}

	fn hits(&self) -> u64 {
		self.hits.get()
	}
}

fn main() {
	let m = Metrics::new();
	m.record_hit();
	m.record_hit();
	println!("hits = {}", m.hits());
}
```

适用场景：

- 计数器/标志位/简单状态机
- “对外不可见”的统计数据
- 只需要复制的标量类型（整数、布尔、`Copy` 小 struct）

不适用：

- 需要借用内部数据（比如拿到 `&String`）
- 需要在内部放复杂结构并返回引用

### 10.1.2 `RefCell<T>`：运行时借用检查

`RefCell<T>` 允许你在运行时执行“借用规则检查”。它提供两类借用：

- `borrow(&self) -> Ref<'_, T>`：共享借用（可同时多个）
- `borrow_mut(&self) -> RefMut<'_, T>`：可变借用（只能一个）

如果你在运行时违反规则，程序会 **panic**。

示例：在 `&self` 方法里向内部 `Vec` 里 push：

```rust
use std::cell::RefCell;

#[derive(Debug)]
struct Logger {
	messages: RefCell<Vec<String>>,
}

impl Logger {
	fn new() -> Self {
		Self { messages: RefCell::new(vec![]) }
	}

	// 注意：签名是 &self，但我们仍然能修改内部 Vec
	fn log(&self, msg: impl Into<String>) {
		self.messages.borrow_mut().push(msg.into());
	}

	fn snapshot(&self) -> Vec<String> {
		// 这里 clone 只是为了教学直观；真实项目里可按需返回引用或迭代
		self.messages.borrow().clone()
	}
}

fn main() {
	let l = Logger::new();
	l.log("hello");
	l.log("world");
	println!("{:?}", l.snapshot());
}
```

一个经典的“会 panic 的反例”（同时拿着共享借用又申请可变借用）：

```rust
use std::cell::RefCell;

fn main() {
	let x = RefCell::new(vec![1, 2, 3]);

	let r = x.borrow();
	// 下一行会 panic：因为 r 仍然活着，不能再 borrow_mut
	// let m = x.borrow_mut();

	println!("len = {}", r.len());
}
```

适用场景：

- trait 规定接口必须是 `&self`，但实现需要改内部状态（缓存、记录、统计）
- 在单线程场景中构建图/树结构，配合 `Rc<T>` 共享所有权：`Rc<RefCell<T>>`

注意：

- `RefCell<T>` **不是线程安全**（`!Sync`），不要跨线程共享。
- 它把“编译期拒绝”变成“运行时 panic”，所以应当确保逻辑上不会违反借用规则。

### 10.1.3 `Cell` vs `RefCell` 怎么选

可以记一个很实用的选择逻辑：

- **能拷贝就用 `Cell`**：简单、开销小、不会因为借用冲突 panic。
- **需要借用/修改复杂结构就用 `RefCell`**：代价是运行时检查和潜在 panic。

---

## 10.2 内部可变性的并发版本：`Mutex`、`RwLock`

`Cell`/`RefCell` 用在单线程里；在多线程里，你需要靠“同步原语”来保证安全。

### 10.2.1 `Mutex<T>`：互斥锁（一次只允许一个线程访问）

`std::sync::Mutex<T>` 的典型用法：

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
	let counter = Arc::new(Mutex::new(0u64));
	let mut handles = vec![];

	for _ in 0..4 {
		let c = Arc::clone(&counter);
		handles.push(thread::spawn(move || {
			for _ in 0..1000 {
				let mut guard = c.lock().unwrap();
				*guard += 1;
				// guard 离开作用域自动 unlock（RAII）
			}
		}));
	}

	for h in handles {
		h.join().unwrap();
	}

	println!("counter = {}", *counter.lock().unwrap());
}
```

核心语义：

- `lock()` 返回一个 guard（`MutexGuard`），它实现了 `Deref`/`DerefMut`，让你像用 `&mut T` 一样用它。
- guard 被 drop 时自动释放锁。

底层实现（高层次理解即可）：

- 锁内部维护一个状态（锁住/未锁）与等待队列。
- 在不同平台上可能使用 OS 原语（如 futex、SRWLock、pthread mutex 等）或等效机制。
- Rust 用 guard 的生命周期把“持锁区间”绑定到作用域，避免忘记释放锁。

常见特性：**poisoning（中毒）**

- 如果持锁期间发生 panic，标准库会把锁标记为 “poisoned”。
- 之后 `lock()` 会返回 `PoisonError`，提示你：受保护数据可能处于不一致状态。

适用场景：

- 多线程共享并更新数据（计数器、缓存、共享 map）
- 访问必须串行的资源（例如某些外设/文件写入队列）

### 10.2.2 `RwLock<T>`：读写锁（多读单写）

`std::sync::RwLock<T>` 允许：

- 多个读锁并存（`read()`）
- 写锁独占（`write()`），且与读锁互斥

示例：读多写少的配置：

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn main() {
	let cfg = Arc::new(RwLock::new(String::from("v1")));

	let cfg_reader = Arc::clone(&cfg);
	let reader = thread::spawn(move || {
		let g = cfg_reader.read().unwrap();
		println!("read cfg = {g}");
	});

	let cfg_writer = Arc::clone(&cfg);
	let writer = thread::spawn(move || {
		let mut g = cfg_writer.write().unwrap();
		*g = "v2".to_string();
	});

	reader.join().unwrap();
	writer.join().unwrap();
}
```

底层实现（高层次理解）：

- 内部维护“读者计数”和“写者状态”。
- 读者计数通常是原子或受保护计数；写者需要阻塞后续读写。
- 同样使用 RAII guard 来自动释放。

适用场景：

- **读多写少**：热点只读配置、共享字典、路由表等

注意：

- `RwLock` 并不一定总比 `Mutex` 快：在竞争激烈或写较多时，读写锁可能更糟。
- 读写锁存在“写者饥饿/读者饥饿”等公平性问题（取决于实现策略）。

---

## 10.3 `UnsafeCell` 是什么？与 `Cell`/`RefCell` 的关系

### 10.3.1 为什么需要 `UnsafeCell<T>`

Rust 对共享引用 `&T` 有一个非常重要的语义：

> 通过 `&T` 不能修改 `T`（这也是编译器优化的重要依据之一）。

如果你想在 `&T` 背后实现“可修改”，就必须告诉编译器：

> 这里的内存可能会被修改，请不要基于“不可变”做错误优化。

`std::cell::UnsafeCell<T>` 就是这个“告诉编译器”的最底层构件。

一句话：**在 Rust 里，几乎所有内部可变性都是通过 `UnsafeCell<T>` 实现的。**

### 10.3.2 `UnsafeCell` 与 `Cell`/`RefCell` 的关系

可以把它们理解成一层层封装：

- `UnsafeCell<T>`：只提供“绕过 `&T` 不可变语义”的能力，本身不保证借用规则，不保证线程安全。
- `Cell<T>`：在 `UnsafeCell` 上提供“拷贝进出”的安全 API（因此限制 `T: Copy` 的使用场景更常见）。
- `RefCell<T>`：在 `UnsafeCell` 上加了一个“借用计数/借用标记”，在运行时检查借用规则，并用 `Ref`/`RefMut` guard 管理释放。

### 10.3.3 `UnsafeCell` 的使用场景

日常业务代码里通常不需要直接用 `UnsafeCell`。

它主要用于：

- 实现底层同步原语/锁/无锁结构
- 实现自己的内部可变性抽象（非常谨慎）
- FFI 或与硬件/共享内存交互时，对内存模型有明确控制需求

如果你打算直接使用 `UnsafeCell`，必须同时自己证明并维护：

- 别名规则不会被破坏（不会出现同时可变/共享的非法组合）
- 多线程下的数据竞争不会发生（否则就是未定义行为）

---

## 10.4 什么是智能指针？`Box`、`Rc`、`Arc`

“智能指针”通常指：

- 行为上像指针（可 `*p`、可通过 `->` 风格访问，Rust 里主要由 `Deref` 支持）
- 但带有额外语义（所有权管理、引用计数、线程安全、析构、借用检查等）

你经常会在智能指针周围看到两个 trait：

- `Deref`/`DerefMut`：允许 `*p`、方法调用的自动解引用（deref coercion）。
- `Drop`：离开作用域时自动清理资源。

### 10.4.1 `Box<T>`：把值放到堆上（单一所有权）

`Box<T>` 表示：`T` 存在堆上，`Box<T>` 本身是一个拥有所有权的指针。

常见用途：

1) **值很大**，但你希望移动/传递成本低（移动 `Box` 只移动一个指针）。

2) **递归类型**（编译器需要类型大小已知，递归字段需要“间接层”）：

```rust
enum List {
	Cons(i32, Box<List>),
	Nil,
}
```

3) **trait object**：在运行时决定具体类型（`Box<dyn Trait>`）。

底层实现（高层次理解）：

- `Box<T>` 本质是一个“指向堆分配的 `T` 的唯一指针”。
- drop 时释放堆内存，并先 drop 其中的 `T`。

### 10.4.2 `Rc<T>`：单线程引用计数共享所有权

`Rc<T>`（Reference Counted）允许**多个所有者**共享同一份数据：

- `Rc::clone(&rc)`：不是深拷贝，而是把引用计数 +1
- 当最后一个 `Rc` 被 drop 时，数据才会被释放

示例：共享不可变数据：

```rust
use std::rc::Rc;

fn main() {
	let s = Rc::new(String::from("hello"));
	let a = Rc::clone(&s);
	let b = Rc::clone(&s);

	println!("{} {}", a, b);
	println!("count = {}", Rc::strong_count(&s));
}
```

限制：

- `Rc<T>` **不是线程安全**（引用计数不是原子操作）。因此 `Rc<T>` 不能跨线程共享。
- `Rc<T>` 默认只提供共享不可变访问；如果你要共享可变状态，常见组合是 `Rc<RefCell<T>>`。

### 10.4.3 `Arc<T>`：线程安全的引用计数共享所有权

`Arc<T>`（Atomic Reference Counted）与 `Rc<T>` 类似，但引用计数用原子操作更新，因此可以跨线程共享。

典型组合：

- `Arc<Mutex<T>>`：跨线程共享可变数据（最常见）
- `Arc<RwLock<T>>`：读多写少的跨线程共享

示例（只展示 `Arc` clone 的语义）：

```rust
use std::sync::Arc;

fn main() {
	let data = Arc::new(vec![1, 2, 3]);
	let a = Arc::clone(&data);
	let b = Arc::clone(&data);
	println!("len = {}", a.len() + b.len());
}
```

注意：

- `Arc<T>` 让“共享所有权”线程安全，但并不让 `T` 自身可变安全；要修改共享数据，仍然需要 `Mutex/RwLock` 等同步。

---

## 10.5 什么是引用计数？`Rc`、`Arc` 如何实现引用计数

### 10.5.1 引用计数的核心思想

引用计数（Reference Counting）是“共享所有权”的一种内存管理策略：

- 每份共享数据旁边维护一个计数器：表示当前还有多少“强引用（strong reference）”指向它。
- 每次克隆所有权（`clone`）时计数 +1。
- 每次一个拥有者被 drop 时计数 -1。
- 当计数变为 0 时释放这份数据。

在 Rust 里：

- `Rc<T>` / `Arc<T>` 用的都是引用计数。
- 它们不需要 GC，但也不是“零成本”：每次 clone/drop 都有计数更新开销。

### 10.5.2 `Rc<T>` 的实现要点

`Rc<T>` 通常可以理解为：

- 堆上有一块分配（allocation），里面放：
  - `strong_count`：强引用计数（非原子）
  - `weak_count`：弱引用计数（非原子）
  - `value: T`
- 栈上/结构体里保存指向该 allocation 的指针。

为什么要有 `Weak`：

- 仅有强引用会导致**引用环无法释放**（A 持有 B，B 持有 A，计数永远不为 0）。
- `Weak<T>` 不会让数据保持存活（不增加 strong count），只增加 weak count。
- 当你需要“可选地拿到数据”时，可以 `weak.upgrade()` 尝试转回 `Rc<T>`：
  - 成功：数据仍然存在
  - 失败：数据已被释放

一个常见结构：父子节点

- 子节点用 `Rc` 指向父会形成环
- 更推荐：父 `Rc` 持有子 `Rc`，子用 `Weak` 指向父

### 10.5.3 `Weak<T>`：真实场景里如何避免引用环

在真实项目里，**树/图结构**是 `Weak` 最常见的落点：

- 父节点拥有子节点：父 → 子 这条边通常是“拥有关系”，用 `Rc<T>`。
- 子节点引用父节点：子 → 父 这条边通常只是“回指（back reference）”，不应让父活得更久，用 `Weak<T>`。

#### 10.5.3.1 反例：用 `Rc` 做回指，会形成引用环

下面这个实现里，`children` 和 `parent` 都是 `Rc`，会形成 `parent -> child -> parent` 的环：

```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
	name: String,
	parent: RefCell<Option<Rc<Node>>>,
	children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
	let parent = Rc::new(Node {
		name: "parent".to_string(),
		parent: RefCell::new(None),
		children: RefCell::new(vec![]),
	});

	let child = Rc::new(Node {
		name: "child".to_string(),
		parent: RefCell::new(None),
		children: RefCell::new(vec![]),
	});

	parent.children.borrow_mut().push(Rc::clone(&child));
	*child.parent.borrow_mut() = Some(Rc::clone(&parent));

	println!(
		"parent strong = {}, child strong = {}",
		Rc::strong_count(&parent),
		Rc::strong_count(&child)
	);

	// main 结束时 parent/child 变量会 drop，但由于形成了引用环：
	// parent 和 child 的 strong_count 都不会变成 0，内存无法释放（逻辑上的泄漏）。
}
```

要点：

- 这不是“未定义行为”，而是**引用计数策略的天然缺陷**：引用环会导致计数永远无法归零。
- 所以 `Rc`/`Arc` 结构里，如果存在“可能回指”的边，几乎都应该用 `Weak`。

#### 10.5.3.2 正解：子指向父用 `Weak`，需要时再 `upgrade()`

下面是常见的树结构写法：父拥有子（`Rc`），子回指父（`Weak`）。

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
	name: String,
	parent: RefCell<Weak<Node>>,
	children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
	let leaf = Rc::new(Node {
		name: "leaf".to_string(),
		parent: RefCell::new(Weak::new()),
		children: RefCell::new(vec![]),
	});

	{
		let branch = Rc::new(Node {
			name: "branch".to_string(),
			parent: RefCell::new(Weak::new()),
			children: RefCell::new(vec![Rc::clone(&leaf)]),
		});

		// leaf 回指 branch：用 Weak，不增加 branch 的 strong_count
		*leaf.parent.borrow_mut() = Rc::downgrade(&branch);

		println!(
			"branch strong = {}, weak = {}",
			Rc::strong_count(&branch),
			Rc::weak_count(&branch)
		);

		// 需要访问父节点时：upgrade 尝试把 Weak 转成 Rc
		let parent = leaf.parent.borrow().upgrade().unwrap();
		println!("leaf.parent = {}", parent.name);
	}

	// branch 已经离开作用域并被释放；leaf 的 parent 只剩 Weak
	assert!(leaf.parent.borrow().upgrade().is_none());
	println!("leaf still alive: {}", leaf.name);
}
```

这里的语义非常适合业务：

- “叶子还活着”并不意味着“父节点必须活着”。
- 需要父节点时才尝试 `upgrade()`；如果失败，就说明父节点已被释放（你可以选择返回 None、忽略、或触发重建逻辑）。

补充：

- `Rc<T>` 的弱引用类型是 `std::rc::Weak<T>`。
- `Arc<T>` 的弱引用类型是 `std::sync::Weak<T>`，通过 `Arc::downgrade(&arc)` 创建。

### 10.5.4 `Arc<T>` 的实现要点

`Arc<T>` 的结构与 `Rc<T>` 类似，不同点在于计数器是原子类型：

- `strong_count: AtomicUsize`
- `weak_count: AtomicUsize`

因此：

- `Arc::clone()` 需要做原子加法
- drop 时需要做原子减法
- 当 strong count 到 0 时释放 `T`；当 weak count 也到 0 时释放 allocation 本身

为了正确性，`Arc` 的 drop/释放路径需要配合合适的内存序（memory ordering）来保证：

- 其他线程对 `T` 的访问不会与释放重排成未定义行为

作为教学材料通常不需要深入到具体内存序细节；你只要记住：

- **`Arc` 比 `Rc` 慢**：因为原子操作开销更高
- **但 `Arc` 才能跨线程**

---

## 小结

- **内部可变性**让你在 `&self` 场景下仍能修改内部：`Cell`（拷贝型）与 `RefCell`（运行时借用检查）。
- **并发内部可变性**用锁来保证线程安全：`Mutex`（互斥）与 `RwLock`（多读单写），通过 RAII guard 自动解锁。
- `UnsafeCell<T>` 是内部可变性的底层基石：它允许在共享引用背后发生写入，但正确性需要更高层抽象来保证。
- **智能指针**不仅是“指针”，还携带所有权/析构/共享等语义：`Box`（堆分配单一所有权）、`Rc`（单线程共享所有权）、`Arc`（线程安全共享所有权）。
- **引用计数**通过 strong/weak 计数管理共享数据生命周期；`Rc` 用非原子计数，`Arc` 用原子计数，`Weak + upgrade()` 用来表达“回指但不拥有”，避免引用环。