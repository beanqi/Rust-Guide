# 第四章 结构体和枚举

在 Rust 中，**结构体（struct）** 和 **枚举（enum）** 是构建自定义数据类型的两大基石，它们与模式匹配一起，使代码更加清晰、安全、类型健全。

---

## 1. 如何定义结构体

结构体是 Rust 中最基本的自定义类型，用于把多个相关的值组合在一起，不同字段可以是不同的类型。结构体定义使用 **`struct`** 关键字：

```rust
struct Person {
    name: String,
    age: u32,
}
```

这个定义相当于其他语言中的类的数据部分；在 Rust 中，**结构体定义本身只包含字段**，方法和关联函数在 `impl` 块中定义。也就是说，数据与行为仍然是绑定的，只是语法上分开书写。

Rust 中 **没有传统意义上的类（class）定义**，而是用结构体 + `impl` 块组合数据和行为。这更接近 **组合优于继承** 的设计思想，避免了复杂的类层次结构。

---

## 2. 如何使用结构体

定义结构体之后，我们可以创建实例（instance）：

```rust
let alice = Person {
    name: String::from("Alice"),
    age: 30,
};
```

访问字段：

```rust
println!("Name: {}, Age: {}", alice.name, alice.age);
```

**字段不可变性**：**默认结构体字段是不可变的**。如果要修改字段，需要让整个结构体实例可变：

```rust
let mut bob = Person {
    name: String::from("Bob"),
    age: 25,
};
bob.age = 26;
```

---

## 3. 结构体命名规范与字段命名规范

遵循 Rust 社区风格：

* **结构体名称**：使用 **PascalCase**（每个单词首字母大写）；
* **字段名称**：使用 **snake_case**（小写并用下划线分隔）；

```rust
struct UserProfile {
    user_name: String,
    email_address: String,
}
```

这种命名约定和 Rust 官方书籍一致，便于代码在团队中共享和阅读。

---

## 4. 结构体方法：关联函数、实例方法、`self` 的用法

方法定义在 `impl` 块里。Rust 的方法**显式声明 `self`**，不像其他语言里省略 `this`：

```rust
impl Person {
    // 关联函数（associated function）
    fn new(name: String, age: u32) -> Person {
        Person { name, age }
    }

    // 实例方法
    fn greet(&self) {
        println!("Hello, my name is {} and I'm {}!", self.name, self.age);
    }

    // 方法可以取所有权、借用可变引用
    fn celebrate_birthday(&mut self) {
        self.age += 1;
    }
}
```

#### `self` 和 `this`

| 方法形式        | 描述                 |
| ----------- | ------------------ |
| `self`      | 获取自身所有权（方法消费掉实例）   |
| `&self`     | 不可变借用实例            |
| `&mut self` | 可变借用实例             |
| 无 `self` 参数 | 关联函数（类似 static 方法） |

注意：Rust 的自动借用/解引用机制会在调用时自动添加 `&` 或 `&mut`，让调用更顺畅。

示例调用：

```rust
let mut p = Person::new(String::from("Carol"), 28);
p.greet();
p.celebrate_birthday();
p.greet();
```

---

## 5. Enum 枚举类型：定义与使用

Rust 的枚举比其他语言更强大——**每个变体不仅有名字，还可以带数据**。

```rust
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
```

带数据的枚举变体：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

每个变体都可以携带不同类型/不同字段数量的数据。

实例化：

```rust
let m1 = Message::Quit;
let m2 = Message::Write(String::from("Hello"));
let m3 = Message::Move { x: 10, y: 20 };
```

在官方 Rust 书中也有类似 IP 地址枚举的例子：可以直接将数据附加到枚举变体，而无需单独结构体来组合种类和地址数据。

---

## 6. `match` 模式匹配结构体和枚举

`match` 是 Rust 中处理枚举和解构数据最主要的方式。它要求穷尽所有可能的情况，从而避免遗漏路径：

```rust
let msg = Message::Move { x: 5, y: 7 };

match msg {
    Message::Quit => println!("Quit"),
    Message::Write(text) => println!("Text message: {}", text),
    Message::Move { x, y } => println!("Move to ({}, {})", x, y),
    Message::ChangeColor(r, g, b) => println!("Color change to RGB({}, {}, {})", r, g, b),
}
```

对于结构体，也可以在 `match` 中解构字段：

```rust
let p = Person { name: String::from("Dan"), age: 40 };

match p {
    Person { name, age: 40 } => println!("{} is 40!", name),
    Person { name, age } => println!("{} is {} years old", name, age),
}
```

此外，Rust 中广泛使用 `if let` 和 `while let` 等配合模式匹配使用的语法，简化只关心某个变体的情况。

例如：

```rust
let maybe = Some(3);
if let Some(x) = maybe {
    println!("x = {x}");
}
```

---

## 元组结构体与单元结构体

Rust 还有一种轻量结构体类型：

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32);
struct UnitStruct;
```

* **元组结构体**：字段没有名字，只通过位置访问；
* **单元结构体**：没有字段，可用于标记或泛型上下文。

