# 12. 异步编程

本章目标：把 Rust async 生态里最容易“会用但不懂”的部分讲清楚。

- **你会写**：`async fn` / `.await` / `tokio::spawn` / `join!` / `select!` / 超时 / Channel / Stream / 异步锁
- **你会懂**：`Future` 的核心职责、`Waker` 的唤醒机制、Tokio runtime 的线程模型与事件模型（大体结构）

---

## 12.1 什么是异步编程？与同步的区别

### 12.1.1 同步：一个任务卡住，线程也卡住

在“同步阻塞”的模型里，如果你在一个线程里做 I/O（比如读 socket、读文件、访问数据库），当 I/O 没准备好时：

- 线程会阻塞等待
- 阻塞期间这条线程几乎什么也做不了

这在“连接数少但每个任务很重”的场景（比如 CPU 密集计算）完全没问题。

### 12.1.2 异步：任务卡住，但线程不必卡住

异步编程要解决的核心矛盾是：

> I/O 等待时间很长，但 CPU 真正干活的时间很短。

异步模型倾向于把“等待”变成一种可管理的状态：

- 任务遇到 I/O 未就绪时**挂起**（yield）
- runtime 把线程去执行别的任务
- I/O 就绪后再把任务**唤醒**继续推进

所以异步通常在以下场景收益很大：

- 高并发 I/O：网络服务、爬虫、网关、代理、消息队列消费者
- 大量连接/请求，且每个请求大部分时间在等待

但异步不一定更快：

- **CPU 密集**：异步不“凭空”增加 CPU，反而可能增加调度开销
- **极低并发**：同步更简单

### 12.1.3 一句话对比：并发结构 vs 并行吞吐

可以把 async 看成是一种“更轻量的并发结构工具”：

- **线程并发**：主要靠 OS 调度；创建/切换开销较大；栈大；适合阻塞调用
- **异步并发**：主要靠 runtime 调度；任务更轻；适合 I/O 等待；但要求“非阻塞”生态

---

## 12.2 Futures 与 async 语法：Future trait 做什么？async/await 怎么工作？

Rust 的 async 不是“魔法线程”，它是编译器 + 库共同实现的一套：

- 编译器把 `async` 函数/块编译成一个**状态机**
- 状态机实现 `Future` trait
- executor（执行器）负责不断 `poll` 这个 future 推进它

### 12.2.1 `Future` trait：可被推进的异步计算

简化理解：一个 `Future` 表示“未来某个时刻能产出一个值”。

它的关键点是：**它不会自己跑**，需要被 executor 驱动。

`Future` trait 的核心方法（概念上）是 `poll`：

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
	type Output;
	fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

`poll` 的返回值：

- `Poll::Ready(val)`：完成，产出结果
- `Poll::Pending`：暂时没法完成（通常因为 I/O 还没准备好）

### 12.2.2 `Waker`：Pending 以后如何“再来一次”？

当 `poll` 返回 `Pending` 时，future 必须保证：

- 已经把“将来可继续推进”的条件注册到某个地方（例如把 waker 挂到 I/O 事件上）
- 当条件满足时，调用 `waker.wake()` 通知 executor：**这个任务可以再 poll 了**

你可以把 `waker` 理解为 “把这个 task 放回就绪队列”。

> 注意：这也是为什么 async 生态强调“不要阻塞”。阻塞会卡住线程，waker 也救不了。

### 12.2.3 `async fn` 的本质：返回一个实现 Future 的状态机

下面这个函数：

```rust
async fn f() -> i32 {
	1
}
```

等价于（概念上）：

- `f()` 返回一个匿名类型 `impl Future<Output = i32>`
- 这个 future 在被 executor `poll` 时最终返回 `Ready(1)`

也就是说：

- 调用 `f()` 不会执行函数体，只会构造 future
- 只有 `.await`（或被 spawn / join 等）才会真正驱动它

### 12.2.4 `.await` 的本质：在挂起点让出控制权

`.await` 只能出现在 async 上下文中。

直观理解：

- `.await` 会“等待”另一个 future 完成
- 但它不是阻塞线程，而是：
  - 当前 future 返回 `Pending`
  - 把自己该怎么继续执行的信息保存在状态机里
  - 由 executor 未来再次 `poll` 来继续

因此：

- async 函数可以在一次调用中多次挂起/恢复
- 每一个 `.await` 都是一个潜在的挂起点

### 12.2.5 为什么需要 `Pin`？

`poll(self: Pin<&mut Self>, ...)` 之所以用 `Pin`，是为了支持“自引用状态机”等场景。

当编译器把 `async fn` 变成状态机时，可能在内部保存指向自身字段的引用（比如为了优化）。如果 future 在内存中被移动，这些引用就会失效。

- `Pin` 的核心承诺：被 pin 住之后，这个值不会再被移动
- 你不需要手写 pin 逻辑，通常由 runtime/库帮你处理（`Box::pin` 等）

---

## 12.3 Tokio：核心概念、基本使用、以及如何与 Futures 结合

Tokio 是 Rust 最主流的异步 runtime 之一，提供：

- executor（任务调度）
- reactor（事件循环：网络 I/O 等）
- timer（sleep/interval/timeout）
- 常用异步原语：Channel、Semaphore、Mutex/RwLock 等

### 12.3.1 最小可运行：`#[tokio::main]` + `.await`

`Cargo.toml`（示意）：

```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
```

示例：

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
	sleep(Duration::from_millis(50)).await;
	println!("hello async");
}
```

`#[tokio::main]` 做的事情大体是：

- 创建一个 Tokio runtime
- 在 runtime 上 `block_on(main_future)`

### 12.3.2 task：`tokio::spawn` 与 JoinHandle

Tokio 的“并发单元”是 task（任务），比 OS 线程轻得多。

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
	let h1 = tokio::spawn(async {
		sleep(Duration::from_millis(50)).await;
		10
	});

	let h2 = tokio::spawn(async {
		sleep(Duration::from_millis(30)).await;
		32
	});

	let a = h1.await.unwrap();
	let b = h2.await.unwrap();
	println!("sum = {}", a + b);
}
```

几点要点：

- `tokio::spawn` 接收一个 future，并让 runtime 负责驱动它
- 返回 `JoinHandle<T>`，`await` 它会拿到 task 的返回值
- **丢弃 `JoinHandle` 不会取消任务**，它只会让任务“分离”继续跑；需要主动取消时用 `JoinHandle::abort()` 或结合 `CancellationToken` 等机制

### 12.3.3 `Send` 约束：为什么 `spawn` 经常要求 `Send + 'static`

Tokio 默认 runtime 是多线程调度器：task 可能从一个工作线程被“偷”到另一个线程继续执行。

因此 `tokio::spawn` 通常要求：

- future 是 `Send`（可以跨线程安全移动）
- future 捕获的数据是 `'static`（不能借用短生命周期栈变量）

如果你确实需要 `!Send` 的 future（例如用了 `Rc`、`RefCell`），可以考虑：

- `tokio::task::LocalSet` + `spawn_local`
- 或使用 current-thread runtime

### 12.3.4 Tokio 与 “通用 Futures 生态” 如何结合

Rust 的 async 是“基于 Future trait 的语言特性”，Tokio 是一个 runtime。

因此：

- 任何实现了 `Future` 的东西理论上都能在 Tokio 上运行（只要它的 I/O / timer 能接到 Tokio 的驱动）
- `async fn` 返回的 `impl Future` 当然也能被 Tokio `spawn`

有时你会用到 `futures` crate 的工具（组合子、`join`、`select`、`Stream` 等）：

```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
futures = "0.3"
```

---

## 12.4 Tokio 的工作原理：任务调度、线程模型、事件模型

这一节不追源码细节，只建立“你脑子里的模型”。

### 12.4.1 两个核心：Scheduler + Reactor

Tokio runtime 可以粗略看成两大块：

- **Scheduler（调度器 / executor）**：决定哪个 task 什么时候被 poll
- **Reactor（反应堆 / 事件循环）**：监听 I/O 就绪事件（可读/可写等），并在就绪时唤醒对应 task

当一个 task 在 `.await` 某个 I/O 时，通常发生：

1. task 被 `poll`
2. 发现 I/O 未就绪，注册 waker 到 reactor
3. task 返回 `Pending`
4. reactor 等待系统事件（epoll/kqueue/IOCP 等）
5. 事件到来，reactor 调用 `waker.wake()`
6. scheduler 把 task 放回就绪队列，再次 `poll`

### 12.4.2 线程模型：current-thread vs multi-thread

Tokio 常见两种 runtime 形态：

- **current-thread**：单线程驱动所有任务（适合嵌入式/简单工具/需要 `!Send`）
- **multi-thread**：线程池 + work-stealing（默认；适合高并发服务）

从使用者角度，差异主要体现在：

- `Send` 要求是否严格
- 任务在哪个线程执行不可预测（multi-thread）

### 12.4.3 协作式调度：为什么“纯 CPU 循环”会饿死别人

Tokio 的 task 是协作式的：

- 任务只有在 `.await`（或显式让出）时才会把执行权交回 runtime
- 如果你写了一个长时间不 `.await` 的纯计算循环，可能导致同线程上的其他任务得不到推进

应对策略：

- 把 CPU 密集任务放到 `tokio::task::spawn_blocking` 或专用线程池
- 适当拆分计算并插入让出点（例如 `tokio::task::yield_now().await`，谨慎使用）

### 12.4.4 计时器：`sleep`/`interval`/`timeout` 的底层直觉

timer 也是一种“事件源”：

- `sleep(d)` 本质上注册一个“到期事件”，到期时唤醒任务
- `timeout(d, fut)` 本质上是让 fut 和一个 timer future 竞速

### 12.4.5 阻塞 I/O 的处理：`std` vs `tokio`

在 async 任务里直接调用阻塞 I/O（例如 `std::fs`、阻塞网络库）会卡住运行线程，拖慢同线程上的所有任务。

常见做法：

- 使用 Tokio 提供的异步 I/O（`tokio::fs` / `tokio::net` 等）
- 把阻塞逻辑放到 `tokio::task::spawn_blocking` 里，避免占用 async 工作线程

---

## 12.5 常见异步编程模式：并发调度、超时、异步 I/O

这一节偏实战。

### 12.5.1 并发执行：`join!` 与 `select!`

**`join!`：并发等待多个 future 全部完成**

```rust
use tokio::time::{sleep, Duration};

async fn a() -> i32 {
	sleep(Duration::from_millis(40)).await;
	1
}

async fn b() -> i32 {
	sleep(Duration::from_millis(10)).await;
	2
}

#[tokio::main]
async fn main() {
	let (x, y) = tokio::join!(a(), b());
	println!("x={x}, y={y}");
}
```

**`select!`：谁先完成用谁（常用于超时/竞速/取消）**

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
	let fast = async {
		sleep(Duration::from_millis(10)).await;
		"fast"
	};

	let slow = async {
		sleep(Duration::from_millis(50)).await;
		"slow"
	};

	tokio::select! {
		v = fast => println!("winner: {v}"),
		v = slow => println!("winner: {v}"),
	}
}
```

### 12.5.2 超时：`timeout`

```rust
use tokio::time::{timeout, Duration, sleep};

#[tokio::main]
async fn main() {
	let work = async {
		sleep(Duration::from_millis(50)).await;
		123
	};

	match timeout(Duration::from_millis(10), work).await {
		Ok(v) => println!("ok: {v}"),
		Err(_) => println!("timeout"),
	}
}
```

要点：

- 超时后返回 `Err`，内部 future 可能会被 drop（等价于一种取消）
- 被 drop 后是否真的“停止 I/O”取决于具体实现（大多数 Tokio I/O 会正确取消/解除注册）

### 12.5.3 有界并发：同时跑 N 个任务（限流）

高并发请求通常要限制并发度，否则：

- 连接/文件句柄耗尽
- 下游被打爆
- 延迟抖动

Tokio 常用做法：`Semaphore`。

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
	let sem = Arc::new(Semaphore::new(2));

	let mut handles = Vec::new();
	for i in 0..5 {
		let sem = sem.clone();
		handles.push(tokio::spawn(async move {
			let _permit = sem.acquire().await.unwrap();
			println!("start {i}");
			sleep(Duration::from_millis(30)).await;
			println!("done  {i}");
		}));
	}

	for h in handles {
		h.await.unwrap();
	}
}
```

### 12.5.4 异步 I/O：TCP echo（核心套路）

Tokio 网络 I/O 类型通常实现 `AsyncRead`/`AsyncWrite`。

下面是一个极简 TCP echo server（示意）：

```rust
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
	let listener = TcpListener::bind("127.0.0.1:8080").await?;

	loop {
		let (mut socket, addr) = listener.accept().await?;
		println!("accepted {addr}");

		tokio::spawn(async move {
			let mut buf = [0u8; 1024];
			loop {
				let n = match socket.read(&mut buf).await {
					Ok(0) => return, // EOF
					Ok(n) => n,
					Err(_) => return,
				};

				if socket.write_all(&buf[..n]).await.is_err() {
					return;
				}
			}
		});
	}
}
```

说明：

- `accept().await` 挂起等待新连接
- 每个连接一个 task（典型“高并发 I/O”写法）
- 真实项目要加：超时、限流、日志、错误处理、优雅退出等

---

## 12.6 扩展用法：Streams 与 Channels

Future 是“最终产出一个值”，而 Stream 更像是“异步迭代器”：

- `Future<Output = T>`：一次性
- `Stream<Item = T>`：多次产出，直到结束

除了 Stream/Channel，实际项目里你还会频繁用到一些“Future 组合工具”（很多来自 `futures` crate）。它们解决的是同一个问题：

> 我现在有一堆 future，想以某种策略把它们跑起来并收集结果。

下面集中介绍几个常用的 micro utilities 以及使用场景。

### 12.6.1 Future 组合工具（`futures::future` + `FutureExt`）

你会遇到两类需求：

- **固定数量**的 future：写死 2~5 个（最适合 `tokio::join!` / `tokio::select!`）
- **动态数量**的 future：运行时才知道有多少（更适合 `join_all` / `FuturesUnordered` / `buffer_unordered`）

并且要先想清楚：

- 你是要“等全部完成”还是“谁先完成先处理”？
- 出错时是“继续收集”还是“尽快失败返回”？
- 是否需要**限流**（有界并发），避免一次性把所有请求打出去？

#### 12.6.1.1 `join_all`：动态数量、全部完成后返回 Vec

`join_all` 的语义：

- 并发驱动一组 futures
- 等它们**全部完成**
- 返回一个 `Vec<Output>`，顺序与输入顺序一致

适用场景：

- 你有一批请求都要跑完（例如批量预热缓存、批量拉取信息）
- 不需要“先完成的先处理”（那更像 Stream）

```rust
use futures::future::join_all;
use tokio::time::{sleep, Duration};

async fn work(i: u64) -> u64 {
	sleep(Duration::from_millis(10 * i)).await;
	i * 10
}

#[tokio::main]
async fn main() {
	let futures = (1..=5).map(work);
	let results = join_all(futures).await;
	println!("{results:?}");
}
```

注意：

- `join_all` 不自带并发上限；如果你传入 10 万个 future，它会尝试同时推进它们（通常不是你想要的）

#### 12.6.1.2 `try_join_all`：动态数量、遇到 Err 尽快返回

当你的 futures 输出是 `Result<T, E>` 时，`try_join_all` 很顺手：

- 全部成功：`Ok(Vec<T>)`
- 任意一个失败：返回 `Err(E)`（实现上通常会 drop 其余 futures，因此表现为“尽快失败”）

适用场景：

- 一组任务只要有一个失败就没意义（例如“所有分片都必须拉取成功”）
- 希望尽快把错误反馈出去

```rust
use futures::future::try_join_all;
use tokio::time::{sleep, Duration};

async fn may_fail(i: u64) -> Result<u64, &'static str> {
	sleep(Duration::from_millis(10)).await;
	if i == 3 { Err("boom") } else { Ok(i) }
}

#[tokio::main]
async fn main() {
	let futures = (1..=5).map(may_fail);
	let r = try_join_all(futures).await;
	println!("{r:?}");
}
```

重要澄清：

- “drop future” ≠ “一定停止所有底层工作”。如果你把工作 `tokio::spawn` 出去了，那么 drop 的只是 JoinHandle；真正的 task 可能还在跑。

#### 12.6.1.3 `select_all`：动态数量、谁先完成先返回

`select_all` 的语义：

- 并发驱动一组 futures
- **第一个完成的**返回出来
- 同时返回：这个完成的结果、它的索引、以及“剩余 futures”

适用场景：

- “竞速”：多个镜像源/多个 DNS/多个副本，谁先响应用谁
- 你需要在拿到第一个结果后决定是否继续跑剩余的（自己选择 drop 或继续）

> 如果你要“反复处理谁先完成”，更推荐用 `FuturesUnordered`（见下）

#### 12.6.1.4 `FuturesUnordered`：把 futures 当成一个“完成顺序流”

`FuturesUnordered` 很像一个 Stream：

- 你可以不断 `push` 新 future 进去
- 每当某个 future 完成，就产出一个结果（完成顺序，不保证输入顺序）

适用场景：

- 动态任务池（任务随时加入）
- 你希望“谁先完成先处理”，并逐步消化结果（而不是等全部完成）

```rust
use futures::{stream::FuturesUnordered, StreamExt};
use tokio::time::{sleep, Duration};

async fn work(i: u64) -> u64 {
	sleep(Duration::from_millis(30 - i * 5)).await;
	i
}

#[tokio::main]
async fn main() {
	let mut set = FuturesUnordered::new();
	for i in 1..=5 {
		set.push(work(i));
	}

	while let Some(v) = set.next().await {
		println!("done: {v}");
	}
}
```

#### 12.6.1.5 限流（有界并发）：`buffer_unordered` / `Semaphore`

如果你有很多个 future，但又想限制同时在飞的数量：

- Stream 风格：把 futures 作为 stream，然后 `buffer_unordered(n)`
- Tokio 原语：用 `Semaphore`（你在 12.5.3 已见过）

`buffer_unordered` 的典型用法（示意）：

```rust
use futures::{stream, StreamExt};
use tokio::time::{sleep, Duration};

async fn work(i: u64) -> u64 {
	sleep(Duration::from_millis(10)).await;
	i
}

#[tokio::main]
async fn main() {
	let results: Vec<u64> = stream::iter(1..=10)
		.map(work)
		.buffer_unordered(3) // 同时最多跑 3 个
		.collect()
		.await;

	println!("{}", results.len());
}
```

场景建议：

- “批处理 + 并发上限 + 逐步收集结果”：优先 `buffer_unordered`
- “共享资源配额（连接数/下游 QPS/文件句柄）”：优先 `Semaphore`

#### 12.6.1.6 `FutureExt` 常见小工具：`map` / `then` / `inspect` / `boxed`

`FutureExt` 提供很多“像 iterator 一样”的组合方法，适合写更函数式的 async 组合逻辑。

常见用法直觉：

- `map`：对输出做纯变换（不引入新的 await）
- `then`：基于输出再串一个 async 计算（会引入新的 await）
- `inspect`：旁路观察（日志/埋点），不改变输出
- `boxed`：把 future 装箱成 trait object（常用于返回类型擦除）

---

### 12.6.2 Stream：异步的迭代器

在 `futures` 生态里，`Stream` trait 的核心也类似 `poll_next`：

- `Ready(Some(item))`：产出一个元素
- `Ready(None)`：结束
- `Pending`：暂时没有新元素

Tokio 侧常用的是 `tokio_stream`（把 Tokio 的东西适配成 Stream）。

示例：把 `interval` 变成一个 Stream（示意写法，依赖 tokio-stream）

```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
tokio-stream = "0.1"
futures = "0.3"
```

```rust
use tokio::time::{self, Duration};
use tokio_stream::wrappers::IntervalStream;
use futures::StreamExt;

#[tokio::main]
async fn main() {
	let interval = time::interval(Duration::from_millis(50));
	let mut stream = IntervalStream::new(interval).take(3);

	while let Some(_tick) = stream.next().await {
		println!("tick");
	}
}
```

### 12.6.3 Channels：消息传递的异步版本

Tokio 提供多种 channel：

- `tokio::sync::mpsc`：多生产者，单消费者（最常用）
- `tokio::sync::oneshot`：一次性发送（请求-响应、通知）
- `tokio::sync::broadcast`：广播（多个订阅者都能收到）
- `tokio::sync::watch`：只保留“最后一个值”（配置热更新、状态同步）

#### 12.6.3.1 mpsc：生产-消费

```rust
use tokio::sync::mpsc;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
	let (tx, mut rx) = mpsc::channel::<i32>(8);

	tokio::spawn(async move {
		for i in 0..5 {
			tx.send(i).await.unwrap();
			sleep(Duration::from_millis(10)).await;
		}
	});

	while let Some(v) = rx.recv().await {
		println!("got {v}");
	}
}
```

要点：

- `channel(8)` 是**有界队列**：满了会让 `send().await` 挂起（天然背压）
- 丢弃所有 sender 后，receiver 会收到 `None` 并结束

#### 12.6.3.2 oneshot：一次性结果

```rust
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
	let (tx, rx) = oneshot::channel::<String>();

	tokio::spawn(async move {
		let _ = tx.send("done".to_string());
	});

	let v = rx.await.unwrap();
	println!("{v}");
}
```

---

## 12.7 异步编程中的锁：Mutex / RwLock 以及与同步锁的区别

Rust 的“锁”在 async 场景里是一个常见坑点：

- 你既可能需要共享可变状态
- 又可能在持锁期间 `.await`

### 12.7.1 同步锁（std::sync） vs 异步锁（tokio::sync）

**`std::sync::Mutex`**：

- `lock()` 是阻塞调用
- 适合：临界区很短，且持锁期间不会 `.await`
- 优点：更轻量、开销更小

**`tokio::sync::Mutex`**：

- `lock().await`：拿不到锁会让出执行权，不阻塞线程
- 适合：你确实可能在持锁期间 `.await`（但这通常意味着你需要重新设计）

经验法则（很重要）：

- 如果持锁期间**不会 await**，优先用 `std::sync::Mutex`
- 只有当你必须在 async 环境下等待锁、并且临界区会跨越 await 时，才用 `tokio::sync::Mutex`

### 12.7.2 经典坑：持锁 `.await` 导致性能问题甚至死锁

反例（示意）：

```rust
use std::sync::Arc;
use tokio::sync::Mutex;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
	let shared = Arc::new(Mutex::new(0));

	let s = shared.clone();
	let h = tokio::spawn(async move {
		let mut g = s.lock().await;
		*g += 1;
		// ❌ 持锁等待：会拖住其他等待锁的任务
		sleep(Duration::from_millis(50)).await;
	});

	h.await.unwrap();
}
```

正确的方向通常是：

- 把 `.await` 放到临界区之外
- 或者把共享状态改为消息传递（channel）

### 12.7.3 `RwLock`：读多写少的共享

`tokio::sync::RwLock` 允许并发读、独占写：

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

#[tokio::main]
async fn main() {
	let data = Arc::new(RwLock::new(vec![1, 2, 3]));

	let r = data.read().await;
	println!("len = {}", r.len());
	drop(r);

	let mut w = data.write().await;
	w.push(4);
}
```

注意：

- `RwLock` 也可能出现写饥饿/读饥饿（取决于实现策略）
- 仍然要避免“持锁 await”

### 12.7.4 更推荐的共享状态方式：Actor / Channel

在 async 服务里，一个非常常见、非常稳的架构是：

- 把状态集中在一个 task（actor）里
- 其他任务通过 channel 给它发消息

好处：

- 避免复杂的锁竞争
- 状态变更路径清晰，可观测性强
- 容易做背压（有界 channel）

---

## 12.8 小结

- async 的核心不是“更快”，而是“把等待从线程里拿出来”，提升 I/O 并发能力
- `Future` = 可被 `poll` 推进的状态机；`Waker` = 可再次推进的通知
- Tokio runtime = 调度器（poll task）+ reactor（I/O 事件）+ timer（时间事件）
- 处理 CPU 密集任务：用 `spawn_blocking` 或线程池，不要在 async task 里死循环
- 锁在 async 里要慎用：优先把 `.await` 移出临界区，或用 channel/actor 替代共享可变
