# 9. 错误与“异常”处理

Rust **没有传统意义上的异常（exception）机制**：不会用 `try { ... } catch { ... }` 在任意位置捕获并继续执行。
Rust 更强调“把失败显式建模进类型系统”，主要通过两条路线：

- **可恢复错误（recoverable）**：用 `Result<T, E>` / `Option<T>` 表达，调用者可选择处理、传播、或转成更高层错误。
- **不可恢复错误（unrecoverable）**：触发 `panic!`，默认会展开栈（unwind）并终止当前线程，通常意味着程序处于无法继续的状态。

---

## 9.1 错误类型：Recoverable vs Unrecoverable

### 9.1.1 什么是“可恢复错误”

“可恢复”的含义是：失败是**预期内**、业务上可接受的分支（例如：文件不存在、网络超时、输入格式不合法），程序可以做出选择：

- 返回默认值 / 提示用户重试
- 记录日志并继续
- 将错误向上传播，让上层决定

Rust 通常用以下类型来表达：

- `Result<T, E>`：失败原因需要说明（`E` 携带信息）。
- `Option<T>`：只有“有/没有”的区别，失败原因不重要或无法提供。

### 9.1.2 什么是“不可恢复错误”

“不可恢复”一般意味着：程序已经进入**不可信状态或违反了关键不变量**（invariant），继续运行可能造成**数据损坏、越界访问被阻止、逻辑错误扩散**等。

典型场景：

- “这不可能发生”的分支真的发生了（逻辑 bug）
- 代码依赖的前置条件被破坏（例如内部状态机非法）
- 越界访问、断言失败

Rust 用 `panic!` 表达这类情况。

### 9.1.3 Rust 的“错误处理哲学”

一句话：**让可能失败的事情在类型上可见**。

- 你看到函数返回 `Result` / `Option`，就知道调用处必须面对失败。
- 你看到 `panic!`，就知道这是一种“程序无法（或不应）继续”的信号，通常代表 bug 或不可接受的状态。

---

## 9.2 `panic!` 机制：触发条件与处理方式

### 9.2.1 `panic!` 是什么

`panic!` 是 Rust 的“紧急停止”机制。触发后：

- 默认策略：**栈展开（unwind）**，逐层调用 `Drop` 清理资源，然后终止当前线程。
- 可选策略：**直接中止（abort）**，不展开栈（更小的二进制、更快，但更难排查）。

### 9.2.2 常见触发条件

1) 显式调用：

```rust
fn main() {
	panic!("boom!");
}
```

2) 通过 `unwrap()` / `expect()`：

```rust
fn main() {
	let x: Option<i32> = None;
	// 运行时 panic：called `Option::unwrap()` on a `None` value
	let _v = x.unwrap();
}
```

3) 断言失败：

```rust
fn main() {
	let a = 1;
	let b = 2;
	assert!(a > b, "a must be greater than b");
}
```

4) 越界访问（例如切片/Vec 下标越界）：

```rust
fn main() {
	let v = vec![1, 2, 3];
	// panic: index out of bounds
	let _x = v[99];
}
```

### 9.2.3 栈展开 vs 直接 abort

你可以在 `Cargo.toml` 配置 profile 的 panic 策略（适合写在教材里作为知识点）：

```toml
[profile.release]
panic = "abort"
```

说明：

- `unwind`：更利于定位问题；会运行 `Drop`。
- `abort`：二进制更小，崩溃更快；但不会运行展开过程中的析构。

### 9.2.4 打印回溯（backtrace）定位 panic

调试时很有用：

- Windows PowerShell：`$env:RUST_BACKTRACE=1`
- CMD：`set RUST_BACKTRACE=1`
- Bash：`RUST_BACKTRACE=1`

然后重新运行程序即可看到回溯。

### 9.2.5 “处理” panic：能不能 catch？

Rust 提供 `std::panic::catch_unwind` 捕获 panic（仅在 unwind 策略下可用），但它**不是**日常错误处理手段：

```rust
use std::panic;

fn main() {
	let result = panic::catch_unwind(|| {
		panic!("panic inside");
	});

	assert!(result.is_err());
}
```

注意点：

- `catch_unwind` 主要用于**隔离第三方代码**、FFI 边界、或测试框架场景。
- 捕获 panic 后继续运行并不总是安全：panic 可能意味着内部状态已损坏。

---

## 9.3 `Result` 与 `Option`

### 9.3.1 `Result<T, E>`：带原因的失败

标准库定义（概念上）：

```rust
enum Result<T, E> {
	Ok(T),
	Err(E),
}
```

最常见的处理方式是 `match`：

```rust
use std::fs::File;

fn main() {
	let f = File::open("hello.txt");

	let _file = match f {
		Ok(file) => file,
		Err(error) => {
			eprintln!("open file failed: {error}");
			return;
		}
	};
}
```

也可以用组合子（combinators）让代码更“函数式”一点：

```rust
fn parse_port(s: &str) -> Result<u16, std::num::ParseIntError> {
	s.parse::<u16>()
}

fn main() {
	let port = parse_port("8080").unwrap_or(80);
	println!("port = {port}");
}
```

常用方法（只列最常见的一批）：

- `unwrap()` / `expect("msg")`：失败就 panic（适合快速验证/原型/测试，**永远不要在生产环境unwrap**）。
- `unwrap_or(default)` / `unwrap_or_else(f)`：给默认值。
- `map` / `and_then`：对 `Ok` 分支变换/链式调用。
- `map_err`：只转换错误类型（很常见）。

### 9.3.2 `Option<T>`：只有“有/没有”

标准库定义（概念上）：

```rust
enum Option<T> {
	Some(T),
	None,
}
```

示例：从字符串里取第一个字符（可能为空）：

```rust
fn first_char(s: &str) -> Option<char> {
	s.chars().next()
}

fn main() {
	let c = first_char("");
	println!("{c:?}");
}
```

### 9.3.3 `Option` 和 `Result` 怎么选

- **需要解释失败原因**：用 `Result`。
- **只关心“有没有”**：用 `Option`。

两者可以互转：

```rust
fn main() {
	let x: Option<i32> = None;

	let r: Result<i32, &str> = x.ok_or("missing value");
	assert!(r.is_err());
}
```

---

## 9.4 错误传播：`?` 运算符、相关 Trait 与常用库

### 9.4.1 手动传播：`match` 逐层返回

没有 `?` 的时候，典型写法是：

```rust
use std::fs;

fn read_username(path: &str) -> Result<String, std::io::Error> {
	let content = match fs::read_to_string(path) {
		Ok(c) => c,
		Err(e) => return Err(e),
	};
	Ok(content)
}
```

### 9.4.2 `?` 运算符：最常见的传播方式

`?` 做两件事：

- 如果是 `Ok(t)` / `Some(t)`，取出里面的 `t` 继续执行。
- 如果是 `Err(e)` / `None`，**提前返回**（early return）。

用 `?` 改写上面的代码：

```rust
use std::fs;

fn read_username(path: &str) -> Result<String, std::io::Error> {
	let content = fs::read_to_string(path)?;
	Ok(content)
}
```

注意：

- `?` 只能用在返回 `Result`/`Option`（或实现了相关“Try”语义的类型）的函数里。
- `main` 也可以返回 `Result`，这在 CLI 程序里非常常见：

```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
	let _n: i32 = "42".parse()?;
	Ok(())
}
```

### 9.4.3 `?` 背后涉及哪些 Trait？

你在日常代码里最常见会遇到的是：

1) **`From`/`Into`：错误类型转换**

`?` 在传播 `Err(e)` 时，会尝试把 `e` 转成当前函数返回的错误类型（如果类型不一致）。这个转换通常通过 `From` 完成：

```rust
// 伪代码含义：如果有 impl From<LowerError> for HigherError
// 那么 ? 可以把 LowerError 自动转成 HigherError
```

这就是为什么你经常会看到自定义错误里写很多 `impl From<...> for MyError`。

2) **`Try`（及相关残差 residual 概念）**

从语言实现角度，`?` 由 `Try` 家族 trait 支撑（稳定版细节你不必死记）。作为教材，你只要记住：

- `Result`/`Option` 都支持 `?`
- “成功继续、失败提前返回”是它的语义

### 9.4.4 自定义错误类型：不依赖第三方库的写法

库（library crate）更推荐定义“结构化错误类型”，便于调用方精确匹配：

```rust
use std::{fmt, io};

#[derive(Debug)]
pub enum ConfigError {
	Io(io::Error),
	InvalidFormat,
}

impl fmt::Display for ConfigError {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		match self {
			ConfigError::Io(e) => write!(f, "io error: {e}"),
			ConfigError::InvalidFormat => write!(f, "invalid config format"),
		}
	}
}

impl std::error::Error for ConfigError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match self {
			ConfigError::Io(e) => Some(e),
			ConfigError::InvalidFormat => None,
		}
	}
}

impl From<io::Error> for ConfigError {
	fn from(value: io::Error) -> Self {
		ConfigError::Io(value)
	}
}

fn load_config(path: &str) -> Result<String, ConfigError> {
	let raw = std::fs::read_to_string(path)?; // io::Error -> ConfigError
	if raw.trim().is_empty() {
		return Err(ConfigError::InvalidFormat);
	}
	Ok(raw)
}
```

这一套“`Display` + `Error` + `From`”是 Rust 生态里很常见的基础组合。

### 9.4.5 `thiserror`：写库错误类型的主流选择

手写 `Display`/`From` 很机械。`thiserror` 用 derive 宏把样板代码大幅减少，适合**库**：

```toml
# Cargo.toml
[dependencies]
thiserror = "1"
```

示例：

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum AppError {
	#[error("io error: {0}")]
	Io(#[from] std::io::Error),

	#[error("invalid port: {0}")]
	InvalidPort(String),
}

fn read_port(path: &str) -> Result<u16, AppError> {
	let s = std::fs::read_to_string(path)?; // std::io::Error 自动 #[from]
	let port: u16 = s.trim().parse().map_err(|_| AppError::InvalidPort(s))?;
	Ok(port)
}
```

要点：

- `#[from]` 会自动生成 `From<...> for AppError`，让 `?` 更丝滑。
- `#[error("...")]` 定义错误展示文本。

### 9.4.6 `anyhow`：写应用错误处理的主流选择

如果你在写 **应用程序（binary/CLI/Web 服务）**，很多时候并不需要把错误精确建模成 enum；你更关心：

- 快速把各种错误统一成一个返回类型
- 携带上下文（context），便于排障

这时常用 `anyhow`：

```toml
# Cargo.toml
[dependencies]
anyhow = "1"
```

示例：

```rust
use anyhow::{Context, Result};

fn load_user_config(path: &str) -> Result<String> {
	let raw = std::fs::read_to_string(path)
		.with_context(|| format!("failed to read config file: {path}"))?;
	Ok(raw)
}

fn main() -> Result<()> {
	let _cfg = load_user_config("config.toml")?;
	Ok(())
}
```

要点：

- `anyhow::Result<T>` 等价于 `Result<T, anyhow::Error>`。
- `Context` / `with_context` 非常适合为“底层错误”补上业务语境。

### 9.4.7 业界常见的分层建议

- **库（library crate）**：倾向使用结构化错误（自定义 enum），常配合 `thiserror`。
  - 好处：调用者可以 `match` 到具体变体，做精确分支处理。
- **应用（binary crate）**：倾向使用 `anyhow` 做“汇总错误”。
  - 好处：开发效率高，上下文丰富，错误链（source chain）清晰。

---

## 9.5 什么时候用 `panic`，什么时候用 `Result`

可以用一个简单的决策表来记：

| 场景 | 推荐 | 理由 |
|---|---|---|
| 文件/网络/用户输入失败 | `Result` | 失败是常态之一，调用者可处理 |
| “没有值也合理”（如查找不到） | `Option` | 不需要错误原因 |
| 违反内部不变量、逻辑 bug | `panic!` | 程序状态不可信，应尽早暴露 |
| 原型/示例/测试 | `unwrap` / `expect` 允许 | 代码更短，失败直接暴露（但别在生产路径滥用） |

### 9.5.1 适合 `panic` 的典型例子

1) 不变量被破坏：

```rust
fn set_age(age: i32) {
	// age < 0 是程序 bug（调用者不应传入）
	assert!(age >= 0, "age must be non-negative");
}
```

2) 你能证明不会失败，但写起来繁琐（或在教学/原型阶段）：

```rust
fn main() {
	// 教学示例：这里假设永远是数字
	let n: i32 = "123".parse().expect("must be a number");
	println!("{n}");
}
```

### 9.5.2 适合 `Result` 的典型例子

```rust
use std::num::ParseIntError;

fn parse_count(s: &str) -> Result<usize, ParseIntError> {
	s.trim().parse::<usize>()
}
```

因为输入是外部世界提供的，失败是“合理分支”，不应把它当成 bug。

### 9.5.3 实战小建议

- 在“库 API”里，除非你能清楚证明调用者违反契约，否则**优先返回 `Result`/`Option`**。
- 在“应用入口”（例如 `main`、HTTP handler）里：
  - 用 `anyhow` 汇总错误，配合 `Context` 增强可观测性。
  - 最终集中打印/记录错误，并选择合适的退出码或响应码。

---

## 小结

- Rust 通过 `Result`/`Option` 表达可恢复错误，通过 `panic!` 表达不可恢复错误。
- `?` 是最常用的错误传播工具，本质是“成功解包、失败提前返回”，并常配合 `From` 做错误转换。
- `thiserror` 适合库：结构化错误 + 便于 `match`；`anyhow` 适合应用：快速统一错误 + 丰富上下文。
- 决策关键：失败是否“预期内”？是否还能安全继续？如果是 bug/不变量破坏，`panic` 更合适；否则用 `Result`/`Option`。