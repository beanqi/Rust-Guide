# 第六章 包管理以及模块管理

写 Rust 项目时，你会频繁遇到三个层级的组织单位：

- **Package（包）**：由 Cargo 管理的一组 crate（由一个 `Cargo.toml` 描述）。
- **Crate（crate）**：一次编译的最小单元（一个库 crate 或一个二进制 crate）。
- **Module（模块，`mod`）**：crate 内部的命名空间与代码组织方式。

它们解决的问题逐层不同：

- Package：依赖管理、构建、发布
- Crate：复用边界（库）/ 可执行入口（bin）
- Module：把 crate 内部的代码按“领域/层次”拆开，并控制可见性

本章会以“从小到大”的方式，讲清楚：`mod` / `use` 怎么写、文件怎么拆、`Cargo.toml` 怎么配、工作区怎么管理，以及大型项目的最佳实践。

------

## 1. Package / Crate / `mod`：用层次化方式管理代码

### 1.1 三者关系一句话版本

- 一个 **Package** 至少包含 **一个 crate**（库 crate 或 bin crate）。
- 一个 **crate** 可以由很多 **module** 组成。
- **module** 可以写在一个文件里，也可以拆成目录 + 多文件。

### 1.2 Cargo 的默认约定

Cargo 会用“约定优于配置”帮你决定 crate 根（crate root）：

- `src/main.rs`：二进制 crate 的根（可执行程序入口）
- `src/lib.rs`：库 crate 的根（可复用库入口）

一个 package 可以同时存在：

- 一个库 crate：`src/lib.rs`
- 一个默认二进制 crate：`src/main.rs`
- 以及多个额外二进制 crate：`src/bin/*.rs`

------

## 2. `mod` 与 `use`：模块形式、可见性与组织方式

这一节是本章重点：你不仅要知道语法，更要知道“工程里该怎么拆”。

### 2.1 `mod`：声明一个模块

`mod` 有两种常见写法：

1) **内联模块**（写在同一个文件里）
2) **外部文件/目录模块**（把模块内容放到其他文件）

#### 例 1：内联模块（适合小示例/小工具）

`src/main.rs`：

```rust
mod math {
	pub fn add(a: i32, b: i32) -> i32 {
		a + b
	}

	fn hidden() {
		// 默认私有：只在 math 内可见
	}
}

fn main() {
	println!("{}", math::add(1, 2));
	// math::hidden(); // ❌ 不可见
}
```

要点：

- 没写 `pub` 的东西默认 **对父模块不可见**（私有）
- `pub` 让“父模块”可以访问该项（函数/结构体/枚举/常量等）

### 2.2 多文件模块：单文件模块 vs 目录模块

Rust 支持把模块拆到文件系统中，最常见的是：

- **单文件模块**：`src/foo.rs` 定义模块 `foo`
- **目录模块**：`src/foo/mod.rs`（或 Rust 2018+ 常用 `src/foo.rs` + `src/foo/xxx.rs` 组合）

> 重要原则：模块树由 crate root 开始“声明”。文件只是模块内容的承载。

#### 例 2：单文件模块（`src/main.rs` + `src/util.rs`）

目录结构：

```
src/
├── main.rs
└── util.rs
```

`src/main.rs`：

```rust
mod util; // 声明：util 模块的内容在 util.rs

fn main() {
	println!("{}", util::greet("Rust"));
}
```

`src/util.rs`：

```rust
pub fn greet(name: &str) -> String {
	format!("Hello, {name}!")
}
```

#### 例 3：目录模块（一个模块里再拆子模块）

目录结构：

```
src/
├── main.rs
└── net/
	├── mod.rs
	├── client.rs
	└── server.rs
```

`src/main.rs`：

```rust
mod net;

fn main() {
	net::client::connect();
	net::server::listen();
}
```

`src/net/mod.rs`：

```rust
pub mod client;
pub mod server;
```

`src/net/client.rs`：

```rust
pub fn connect() {
	println!("client connect");
}
```

`src/net/server.rs`：

```rust
pub fn listen() {
	println!("server listen");
}
```

要点：

- `net` 是模块；`net::client` / `net::server` 是子模块
- 子模块是否对外可见取决于 `pub mod ...`（以及子模块内 items 是否 `pub`）

#### 例 3.1：不使用 `mod.rs` 的写法（Rust 2018+ 常见）

如果你不喜欢 `mod.rs`，也可以用“同名文件 + 同名目录”的组合：

目录结构：

```
src/
├── main.rs
├── net.rs
└── net/
	├── client.rs
	└── server.rs
```

`src/main.rs`：

```rust
mod net;

fn main() {
	net::client::connect();
}
```

`src/net.rs`（相当于之前的 `src/net/mod.rs`，用于声明子模块）：

```rust
pub mod client;
pub mod server;
```

### 2.3 `use`：把长路径“引入”到当前作用域

`use` 的本质是给路径起别名/缩短路径。典型用法：

#### 例 4：`use` 缩短路径

```rust
use std::collections::HashMap;

fn main() {
	let mut map: HashMap<&str, i32> = HashMap::new();
	map.insert("a", 1);
}
```

#### 例 5：`use` 引入到模块（推荐把 use 放在模块顶部）

```rust
mod service {
	use std::time::Duration;

	pub fn timeout() -> Duration {
		Duration::from_secs(1)
	}
}
```

#### 例 6：`as` 别名（避免命名冲突）

```rust
use std::io::Result as IoResult;

fn f() -> IoResult<()> {
	Ok(())
}
```

#### 例 7：`pub use` 重新导出（对外提供更稳定/更友好的 API）

这是大型项目里非常常见的技巧：内部模块结构可以变，但对外路径尽量稳定。

`src/lib.rs`：

```rust
mod internal {
	pub mod user {
		pub struct User {
			pub id: u64,
		}
	}
}

pub use internal::user::User; // 对外暴露 crate::User
```

使用方：

```rust
use your_crate::User;
```

### 2.4 可见性规则：`pub`、`pub(crate)`、`pub(super)`

可见性默认是“私有（private）”。常用的几种粒度：

- `pub`：对外公开（从父模块可见，一路到 crate 外）
- `pub(crate)`：仅 crate 内可见（对外部依赖不可见）
- `pub(super)`：仅父模块可见
- `pub(in path)`：仅某个指定模块路径内可见

#### 例 8：同一个 crate 内的“对内公开”

```rust
mod a {
	pub(crate) fn only_in_this_crate() {}
}

fn main() {
	a::only_in_this_crate();
}
```

如果这是一个库 crate，外部依赖将无法调用 `only_in_this_crate`。

#### 例 9：只对父模块开放（`pub(super)`）

```rust
mod parent {
	mod child {
		pub(super) fn helper() {
			println!("only parent can call");
		}
	}

	pub fn run() {
		child::helper();
	}
}

fn main() {
	parent::run();
}
```

### 2.5 一个容易踩的点：`mod` 是“声明”，不是“导入”

- `mod foo;`：告诉编译器“这个模块存在，内容在某个文件/目录里”
- `use foo::bar;`：把路径引入当前作用域，方便使用

工程里通常两者都会出现：

1) 在 crate root（`main.rs`/`lib.rs`）用 `mod` 建模块树
2) 在需要使用的地方用 `use` 缩短路径

------

## 3. Crate 与 Cargo.toml：依赖、发布、lib/bin 的区别

### 3.1 Crate 是什么：库 crate vs 二进制 crate

- **二进制 crate（bin）**：有 `fn main()`，产物是可执行文件
- **库 crate（lib）**：没有 `main`，对外暴露 API，供其它 crate 依赖

在同一个 package 里你可以同时拥有 lib + bin：

```
your_pkg/
├── Cargo.toml
└── src/
	├── lib.rs
	└── main.rs
```

此时：

- `cargo build` 会构建库与二进制
- 你的 `main.rs` 里可以 `use your_pkg::...` 来使用同包的库（同名 crate）

### 3.2 Cargo.toml 的作用：package 元信息 + 依赖声明

一个典型的 `Cargo.toml`：

```toml
[package]
name = "demo_pkg"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.8"
serde = { version = "1", features = ["derive"] }
```

要点：

- `[package]`：包名、版本、edition、作者、描述等
- `[dependencies]`：外部依赖（来自 crates.io 或其它来源）

补充：一个 package 如果要显式声明多个 bin（除了 `src/bin/*.rs` 的约定方式），也可以在 `Cargo.toml` 使用 `[[bin]]` 配置；多数情况下用 `src/bin/` 目录更简单。

### 3.3 引入外部包（crates.io）与 `use` 的关系

步骤通常是：

1) 在 `Cargo.toml` 增加依赖
2) 在代码里 `use` 对应路径

例如：

```toml
[dependencies]
rand = "0.8"
```

```rust
use rand::Rng;

fn main() {
	let x = rand::thread_rng().gen_range(1..=10);
	println!("x={x}");
}
```

### 3.4 路径依赖（本地开发常用）

当你在同一台机器上开发多个 crate，经常用本地路径依赖：

```toml
[dependencies]
my_utils = { path = "../my_utils" }
```

这在工作区（workspace）里更常见，下一节会讲。

### 3.5 发布自己的 crate 到 crates.io

发布是“工程化流程”，你至少需要准备：

- `Cargo.toml` 的元信息：`name`、`version`、`description`、`license`（或 `license-file`）等
- README（通常是 `README.md`）
- 确认没有把敏感信息放进包里

典型流程：

1) 登录（一次性）：

```bash
cargo login <your-token>
```

2) 先在本地检查包内容：

```bash
cargo package
```

3) 发布：

```bash
cargo publish
```

版本管理通常遵循语义化版本（SemVer）：

- 修复 bug：`0.1.0 -> 0.1.1`
- 向后兼容新增功能：`0.1.0 -> 0.2.0`（在 0.x 阶段语义更灵活）
- 破坏性修改：`1.0.0 -> 2.0.0`

> 实战建议：先把 crate 的公开 API 控制在小范围，通过 `pub use`/`prelude` 提供稳定入口；内部模块结构可以迭代。

------

## 4. Workspace：创建与管理、多包依赖关系（进阶内容，可以先不看）

当项目变大时，单一 crate 往往不够用：

- 你想把“通用库”拆出来给多个服务复用
- 你想把“二进制程序”和“库”分开编译/发布
- 你想多个 crate 共享同一套依赖版本与构建缓存

这时就用 **workspace**（工作区）。

### 4.1 一个典型 workspace 的结构

```
my_ws/
├── Cargo.toml          # workspace 根
├── crates/
│   ├── core/
│   │   ├── Cargo.toml
│   │   └── src/lib.rs
│   └── cli/
│       ├── Cargo.toml
│       └── src/main.rs
└── README.md
```

workspace 根 `Cargo.toml`：

```toml
[workspace]
members = [
  "crates/core",
  "crates/cli",
]
resolver = "2"
```

### 4.2 workspace 内部 crate 之间怎么依赖

例如让 `cli` 依赖 `core`：

`crates/cli/Cargo.toml`：

```toml
[dependencies]
core = { path = "../core" }
```

`crates/cli/src/main.rs`：

```rust
fn main() {
	println!("{}", core::hello());
}
```

`crates/core/src/lib.rs`：

```rust
pub fn hello() -> &'static str {
	"hello from core"
}
```

### 4.3 workspace 的常见好处

- **共享构建缓存**：改一个 crate 不会让所有 crate 全量重编
- **统一依赖版本**：减少“同一依赖多版本并存”的风险
- **清晰分层**：例如 `core`（领域）/ `infra`（基础设施）/ `cli`（入口）/ `server`（服务）

> 如果你准备把某个 crate 发布到 crates.io，也可以让它同时在 workspace 中参与开发；发布时只对该 crate 执行 `cargo publish`。

------

## 5. Cargo 常用命令：构建、运行、测试、文档与项目管理

Cargo 是 Rust 的构建系统与包管理器。下面这些命令在日常开发中最常用。

### 5.1 构建与运行

- `cargo build`：构建（debug 默认）
- `cargo build --release`：构建 release（开启优化）
- `cargo run`：构建 + 运行默认 bin
- `cargo run --bin <name>`：运行指定二进制（当有多个 bin）

### 5.2 测试

- `cargo test`：运行所有测试
- `cargo test <pattern>`：按名字过滤
- `cargo test -- --nocapture`：显示测试输出

### 5.3 文档

- `cargo doc`：生成文档
- `cargo doc --open`：生成并打开

库 crate 写文档注释（`///`）后，`cargo doc` 会自动把它变成可浏览的 API 文档：

```rust
/// 计算 a+b
///
/// # Examples
///
/// ```
/// assert_eq!(add(1, 2), 3);
/// ```
pub fn add(a: i32, b: i32) -> i32 {
	a + b
}
```

### 5.4 依赖与检查

- `cargo check`：快速类型检查（通常比 build 快）
- `cargo fmt`：格式化（需要 rustfmt 组件）
- `cargo clippy`：静态检查（需要 clippy 组件）
- `cargo update`：更新 `Cargo.lock`（按策略升级依赖）

关于 `Cargo.lock`：

- **应用/二进制项目**：通常建议提交 `Cargo.lock`，保证可复现构建
- **库 crate**：是否提交 `Cargo.lock` 取决于团队策略（很多库不会提交），但在 workspace 里往往仍会出现一份锁文件

### 5.5 workspace 场景下的常用参数

- `cargo build -p <crate_name>`：只构建某个成员
- `cargo test -p <crate_name>`：只测某个成员
- `cargo build --workspace`：构建整个工作区（有时默认就会这样做）

------

## 6. 最佳实践：如何组织大型 Rust 项目（模块系统 + 包管理）

这里给一套“能落地”的经验规则，目标是：

- 对外 API 稳定、对内结构可演进
- 模块边界清晰、可见性最小化
- 编译速度与可维护性兼顾

### 6.1 公共 API 与内部实现分离

推荐做法：

1) 在 `lib.rs` 做“门面（facade）”：
   - `mod ...` 声明内部模块树
   - `pub use ...` 重新导出对外 API
2) 内部模块用 `pub(crate)` 暴露给 crate 内其它模块即可

示例结构：

```
src/
├── lib.rs
├── api.rs
└── internal/
	├── mod.rs
	└── impls.rs
```

`lib.rs`：

```rust
mod api;
mod internal;

pub use api::*;
```

这样外部用户只需要记住 `your_crate::SomeType`，而不是 `your_crate::internal::impls::SomeType`。

### 6.2 可见性“最小化”原则

- 能 `pub(crate)` 就不要 `pub`
- 能 `pub(super)` 就不要 `pub(crate)`
- 把真正对外的东西集中到少数模块（例如 `api` 或 `prelude`）

效果是：

- 你重构内部代码时，不会破坏外部用户
- 编译器也能帮你防止“乱用内部细节”

### 6.3 模块按“领域/层次”组织，而不是按“技术细节”碎片化

更推荐：

- `user`, `order`, `payment`（领域）

谨慎：

- `utils`, `helpers`, `common`（容易变成“垃圾抽屉”）

如果确实需要 `utils`，也建议把它拆成更具体的子模块：

- `time_utils`, `string_utils`, `io_utils`

### 6.4 crate 拆分时机：不要过早，也不要过晚

一般经验：

- 早期：一个 package + 一个 crate + 多模块，足够
- 中期：当某一块逻辑需要被多个二进制复用，或编译边界清晰时，再拆 crate
- 后期：用 workspace 管理多个 crate，控制依赖方向（例如 `core` 不依赖 `cli`）

### 6.5 依赖方向与“层次化”

建议建立清晰依赖层次（示例）：

- `core`：领域模型与核心逻辑（尽量少依赖第三方）
- `infra`：数据库/网络/文件等基础设施（依赖较多）
- `app`/`service`：业务编排
- `cli`/`server`：入口（bin）

原则：上层依赖下层，避免反向依赖与循环依赖。

------

## 本章小结

- Package/Crate/Module 是 Rust 代码组织的三层结构：Cargo 管 package，crate 是编译单元，`mod` 组织 crate 内部。
- `mod` 用来“声明模块树”，`use` 用来“缩短路径”，`pub`/`pub(crate)`/`pub(super)` 控制可见性。
- `Cargo.toml` 定义包元信息与依赖；lib/bin 可以同包共存；发布到 crates.io 需要完善元信息并用 `cargo publish`。
- workspace 适合多 crate 的协作开发，支持成员间 path 依赖与共享构建缓存。
- 大型项目建议：对外 API 集中导出（`pub use`），对内实现最小可见性，按领域拆模块/拆 crate，保持依赖方向清晰。