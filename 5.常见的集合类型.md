# 第五章 常见的集合类型

Rust 的集合类型（collections）解决的是同一类问题：**元素数量在运行期变化**、**需要动态增长**、并且往往需要**高性能**与**内存安全**。

本章围绕三种最常见集合：

- `Vec<T>`：最常用的动态数组
- `String` / `&str`：UTF-8 字符串（`String` 本质上是 `Vec<u8>` 的包装）
- `HashMap<K, V>`：键值对映射

以及一个贯穿所有集合的“核心能力”：**迭代器**。

------

## 1. 集合类型的存储结构（栈/堆）与动态扩容

这一节的目标是回答两个关键问题：

1. 这些集合“变量本身”放在哪里？
2. 真正的数据放在哪里？增长时发生什么？

Rust 里很多集合类型在栈上都只保存一个“句柄”（handle），真正的数据在堆上。

### 1.1 `Vec<T>` 的内存布局

`Vec<T>` 是一个动态数组。你可以把它理解为：

- 栈上：一个小结构体，记录指向堆的指针 `ptr`、当前长度 `len`、容量 `cap`
- 堆上：一段连续内存，用来存放元素

示意图：

```
栈上（Vec 句柄）                堆上（连续缓冲区）
+---------------------+        +-----------------------------+
| v: Vec<i32>         | -----> | [10, 20, 30, _, _, ...]     |
| ptr, len=3, cap=8   |        +-----------------------------+
+---------------------+
```

#### 动态扩容（reallocation）会发生什么？

当你 `push` 新元素，而 `len == cap` 时，`Vec` 通常会：

1. 向分配器申请一块更大的堆内存（增长策略常见是“倍增”，但**不保证**固定倍数）
2. 把旧数据拷贝/移动到新内存
3. 释放旧内存
4. 更新 `ptr/cap`

这意味着：

- **扩容可能很贵**（搬迁 + 重新分配）
- **扩容会导致所有指向元素的引用失效**（因为元素可能搬家了）

因此在项目里常用的优化手段是：

- `Vec::with_capacity(n)`：预留容量
- `v.reserve(more)` / `v.reserve_exact(more)`：提前扩容

```rust
fn main() {
	let mut v: Vec<i32> = Vec::with_capacity(8);
	for i in 0..8 {
		v.push(i);
	}
	v.reserve(100); // 提前把容量增大，减少后续多次扩容
}
```

### 1.2 `String` 的内存布局：本质是 `Vec<u8>`

`String` 是一个**拥有所有权、可增长、UTF-8 编码的字符串**。它的内部布局与 `Vec<u8>` 几乎一致：

- 栈上：`(ptr, len, cap)`
- 堆上：UTF-8 字节序列

因此 `String` 的增长、本质上就是字节数组的增长：`push` / `push_str` 可能触发重新分配。

### 1.3 `HashMap<K, V>` 的内存布局：栈上句柄 + 堆上桶（buckets）

`HashMap` 也是“栈上一个句柄 + 堆上数据结构”。它在堆上维护桶数组（bucket table），通常会根据装载因子（load factor）自动扩容并重新散列（rehash）。

重要结论：

- `HashMap` 的插入在某些时刻可能触发**扩容 + rehash**，成本会比一次普通插入高很多
- 扩容同样会让“指向内部元素的引用”失效，因此长期借用 map 内部元素时要格外谨慎

### 1.4 小结：栈上放“描述信息”，堆上放“真实数据”

- `Vec<T>`：栈上 `(ptr, len, cap)`，堆上连续元素
- `String`：同上（堆上是 UTF-8 字节）
- `HashMap<K,V>`：栈上句柄，堆上桶表 + 键值存储

------

## 2. `Vec<T>` 的常用操作

`Vec<T>` 是 Rust 项目里使用频率最高的集合类型之一。

### 2.1 创建与初始化

```rust
fn main() {
	let v1: Vec<i32> = Vec::new();
	let v2 = vec![1, 2, 3];

	let mut v3 = Vec::with_capacity(10);
	v3.push(42);

	println!("v1 len={} v2 len={} v3 cap={}", v1.len(), v2.len(), v3.capacity());
}
```

### 2.2 增：`push`、`extend`

```rust
fn main() {
	let mut v = vec![1, 2, 3];
	v.push(4);
	v.extend([5, 6, 7]);
	println!("{v:?}");
}
```

### 2.3 查：索引与 `get`（推荐优先 `get`）

```rust
fn main() {
	let v = vec![10, 20, 30];

	let x = v[1];
	println!("x={x}");

	match v.get(100) {
		Some(value) => println!("value={value}"),
		None => println!("out of bounds"),
	}
}
```

区别：

- `v[index]`：越界会 panic（更适合你“确信不越界”的场景）
- `v.get(index)`：返回 `Option<&T>`，更稳健

### 2.4 改：通过索引或可变引用

```rust
fn main() {
	let mut v = vec![1, 2, 3];
	v[0] = 10;

	if let Some(x) = v.get_mut(1) {
		*x *= 10;
	}

	println!("{v:?}");
}
```

### 2.5 删：`pop`、`remove`、`swap_remove`、`retain`

```rust
fn main() {
	let mut v = vec![10, 20, 30, 40];

	let last = v.pop(); // 移除最后一个元素
	println!("pop: {last:?}, v={v:?}");

	let removed = v.remove(1); // 删除指定元素并左移（保持顺序）
	println!("remove: {removed}, v={v:?}");

	let mut v2 = vec![1, 2, 3, 4, 5];
	let removed2 = v2.swap_remove(1); // 指定位置元素与末尾交换再 pop（不保持顺序，但更快）
	println!("swap_remove: {removed2}, v2={v2:?}");

	let mut v3 = vec![1, 2, 3, 4, 5, 6];
	v3.retain(|x| x % 2 == 0); // 保留偶数
	println!("retain: v3={v3:?}");
}
```

经验：

- 需要保持顺序：`remove`
- 不关心顺序但追求性能：`swap_remove`
- 批量按条件删除：`retain`

### 2.6 遍历：`for` + 借用/可变借用/所有权

```rust
fn main() {
	let mut v = vec![10, 20, 30];

	// 1) 只读遍历：借用
	for x in &v {
		println!("read {x}");
	}

	// 2) 可变遍历：可变借用
	for x in &mut v {
		*x += 1;
	}
	println!("after mut: {v:?}");

	// 3) 消费遍历：拿走所有权
	for x in v {
		println!("owned {x}");
	}

	// println!("{v:?}"); // ❌ v 已被 move
}
```

### 2.7 常见坑：push 时借用元素

下面这种写法会报错：

```rust
fn main() {
	let mut v = vec![1, 2, 3];
	let first = &v[0];
	// v.push(4); // ❌ 可能扩容，导致 first 悬垂
	println!("{first}");
}
```

原因：`push` 可能触发扩容，扩容会搬迁数据，导致 `first` 指向旧地址。

解决方式一般是：

- 先把值拷贝出来（如果 `T: Copy`），或者 `clone` 一个
- 或提前 `reserve` / `with_capacity` 保证不会扩容（但这只是“优化技巧”，不是通用逻辑保证）

### 2.8 项目中的常用使用范式

- 把 `Vec` 当“栈”（stack）：用 `push` 入栈、`pop` 出栈，这是非常常见且高效的模式。
- 批量构建列表：如果你大概知道数据规模，优先 `Vec::with_capacity(n)` 或 `reserve`，减少扩容与拷贝。
- 频繁“从中间/开头删除”不是 `Vec` 的强项：
	- 中间删除用 `swap_remove`（不保序）或 `retain`（批量过滤）
	- 需要高频 pop front / push front 的队列语义，通常更适合 `std::collections::VecDeque`

------

## 3. 字符串：`String` 与 `&str`

Rust 的字符串常见有两种：

- `String`：拥有所有权、可增长、堆分配
- `&str`：字符串切片（borrow），通常指向 `String` 的一部分或字符串字面量

### 3.1 `String` vs `&str`：所有权与使用场景

| 类型 | 是否拥有数据 | 是否可变/可增长 | 常见来源 | 典型用途 |
|---|---|---|---|---|
| `String` | ✅ 有所有权 | ✅ 可增长（堆） | `String::from(...)`、读取文件/网络 | 需要修改/拼接/长期持有 |
| `&str` | ❌ 借用 | ❌ 不可直接增长 | 字面量、`String` 的切片、函数入参 | 只读视图、函数参数更通用 |

函数参数经验：能用 `&str` 就用 `&str`，更通用。

```rust
fn greet(name: &str) {
	println!("Hello, {name}!");
}

fn main() {
	let s1 = "Rust"; // &'static str
	let s2 = String::from("Ferris");
	greet(s1);
	greet(&s2);
}
```

### 3.2 创建、追加、插入

```rust
fn main() {
	let mut s = String::new();
	s.push('R');
	s.push_str("ust");
	println!("{s}");

	let mut s2 = String::from("Hello");
	s2.insert(5, '!');
	println!("{s2}");
}
```

### 3.3 拼接：`+` 与 `format!`

#### `+` 的规则（很重要）

`String + &str -> String`，左边的 `String` 会被移动（move）。

```rust
fn main() {
	let s1 = String::from("hello");
	let s2 = String::from(" world");
	let s3 = s1 + &s2;
	// println!("{s1}"); // ❌ s1 被 move
	println!("{s3}");
}
```

#### `format!` 更推荐

`format!` 不会移动原字符串，读写更直观：

```rust
fn main() {
	let a = String::from("hello");
	let b = String::from("world");
	let s = format!("{a}, {b}!");
	println!("a={a}, b={b}, s={s}");
}
```

### 3.4 查询与遍历：字节 / 字符 / 词

Rust 的字符串是 **UTF-8 字节序列**。因此：

- `len()` 返回的是**字节数**，不是“字符数”
- 直接用索引访问 `s[i]` 被禁止（因为 UTF-8 变长，$O(1)$ 索引不成立）

```rust
fn main() {
	let s = String::from("中国");
	println!("bytes len = {}", s.len()); // 6

	for b in s.bytes() {
		print!("{b} ");
	}
	println!();

	for c in s.chars() {
		println!("char: {c}");
	}
}
```

### 3.5 字符串切片：一定要落在字符边界上

```rust
fn main() {
	let s = String::from("Здравствуйте");
	// let x = &s[0..1]; // ❌ panic：不是字符边界
	let ok = &s[0..2]; // ✅ 这里刚好是一个 UTF-8 字符的边界（示例）
	println!("{ok}");
}
```

经验：

- 如果你要按“人类可见字符”处理，通常应该用 `chars()` 或更高层的分词/字素簇库（标准库不直接提供 grapheme cluster 支持）

------

## 4. `HashMap<K, V>`：使用场景与常用操作

`HashMap` 适合处理“用 key 快速定位 value”的需求，例如：

- 计数统计：词频、请求次数
- 去重/缓存：是否出现过、映射关系
- 配置表/索引：从 id -> struct

使用前需要引入：

```rust
use std::collections::HashMap;
```

### 4.1 创建、插入、查询

```rust
use std::collections::HashMap;

fn main() {
	let mut scores = HashMap::new();
	scores.insert(String::from("Alice"), 10);
	scores.insert(String::from("Bob"), 20);

	// get 返回 Option<&V>
	if let Some(v) = scores.get("Alice") {
		println!("Alice: {v}");
	}

	println!("contains Bob? {}", scores.contains_key("Bob"));
}
```

注意：`get("Alice")` 之所以能用 `&str`，是因为 `String` 的 key 可以通过借用形式查询（依赖 `Borrow`/`Hash`/`Eq` 等 trait 组合）。

### 4.2 覆盖插入与“只在不存在时插入”：`entry` API

```rust
use std::collections::HashMap;

fn main() {
	let mut map = HashMap::new();
	map.insert("k", 1);
	map.insert("k", 2); // 覆盖
	println!("k={}", map.get("k").unwrap());

	let mut map2: HashMap<String, i32> = HashMap::new();
	map2.entry("Rust".to_string()).or_insert(1);
	map2.entry("Rust".to_string()).or_insert(999); // 不会覆盖
	println!("Rust={}", map2.get("Rust").unwrap());
}
```

`entry` 在写业务逻辑（计数、累加、初始化）时非常常用。

### 4.3 删除：`remove`

```rust
use std::collections::HashMap;

fn main() {
	let mut map = HashMap::new();
	map.insert("a", 1);
	let removed = map.remove("a");
	println!("removed={removed:?} len={}", map.len());
}
```

### 4.4 遍历：键、值、键值对

```rust
use std::collections::HashMap;

fn main() {
	let mut map = HashMap::new();
	map.insert("a", 1);
	map.insert("b", 2);

	for (k, v) in &map {
		println!("{k} -> {v}");
	}

	for k in map.keys() {
		println!("key={k}");
	}

	for v in map.values() {
		println!("value={v}");
	}
}
```

提示：`HashMap` 的遍历顺序通常不稳定（与 hash/扩容有关），不要依赖顺序。

### 4.5 项目示例：词频统计（经典用法）

```rust
use std::collections::HashMap;

fn main() {
	let text = "hello rust rust book book";
	let mut freq: HashMap<&str, usize> = HashMap::new();

	for word in text.split_whitespace() {
		*freq.entry(word).or_insert(0) += 1;
	}

	println!("{freq:?}");
}
```

------

## 5. 迭代器：概念、链式调用、读取/修改集合数据

迭代器（Iterator）是 Rust 标准库最重要的抽象之一。

你可以把它理解为：

- 一个“按需产出元素”的对象
- 常用方法（`map/filter/take/skip/fold/...`）可以通过**链式调用组合**
- 大量集合操作都可以表达为“**迭代器管道**”

### 5.1 `iter` / `iter_mut` / `into_iter`：三种迭代方式

以 `Vec<T>` 为例，三者语义分别是：

- `iter()`：**产生 `&T`（只读借用）**
- `iter_mut()`：**产生 `&mut T`（可变借用）**
- `into_iter()`：**产生 `T`（拿走所有权，消费集合）**

```rust
fn main() {
	let mut v = vec![1, 2, 3];

	for x in v.iter() {
		println!("iter: {x}");
	}

	for x in v.iter_mut() {
		*x *= 10;
	}
	println!("after iter_mut: {v:?}");

	for x in v.into_iter() {
		println!("into_iter: {x}");
	}

	// println!("{v:?}"); // ❌ v 已被消费
}
```

补充：在 `for` 循环里，`for x in v` 实际上会调用 `IntoIterator`。因此：

- `for x in v`：通常等价于 `v.into_iter()`（消费 v）
- `for x in &v`：等价于 `(&v).into_iter()`，得到 `&T`
- `for x in &mut v`：等价于 `(&mut v).into_iter()`，得到 `&mut T`

### 5.2 常用迭代器方法：`map`、`filter`、`collect`

```rust
fn main() {
	let v = vec![1, 2, 3, 4, 5, 6];

	let evens_squared: Vec<i32> = v
		.iter()
		.filter(|x| **x % 2 == 0)
		.map(|x| x * x)
		.collect();

	println!("{evens_squared:?}");
}
```

注意：

- `iter()` 产生 `&i32`，所以 `filter` 里是 `&&i32`（闭包参数是引用）
- 你也可以用 `.copied()` / `.cloned()` 把 `&T` 转成 `T`

例如：

```rust
fn main() {
	let v = vec![1, 2, 3];
	let owned: Vec<i32> = v.iter().copied().collect();
	println!("owned={owned:?}");
}
```

### 5.3 修改集合数据：`iter_mut` 或“生成新集合”

#### 原地修改（in-place）

```rust
fn main() {
	let mut v = vec![1, 2, 3];
	v.iter_mut().for_each(|x| *x += 100);
	println!("{v:?}");
}
```

#### 生成新集合（更函数式）

```rust
fn main() {
	let v = vec![1, 2, 3];
	let v2: Vec<i32> = v.iter().map(|x| x + 100).collect();
	println!("v={v:?} v2={v2:?}");
}
```

### 5.4 `Iterator` 的“惰性”与 `collect`

多数迭代器方法是惰性的：只有当你调用“消费型”方法（如 `collect`、`sum`、`count`、`for_each`、`fold`）时，链式操作才会真正执行。

这也是迭代器高效的原因之一：它允许编译器优化，并避免不必要的中间集合。

------

## 本章小结

- `Vec/String/HashMap` 都是“栈上句柄 + 堆上数据”的典型集合；扩容可能触发重新分配。
- `Vec<T>` 最常用；注意 `push` 可能导致引用失效，建议合理 `with_capacity/reserve`。
- `String` 是 UTF-8 字节序列；`len` 是字节数；切片要落在字符边界；拼接推荐 `format!`。
- `HashMap` 适合映射与统计；常用 `entry().or_insert(...)` 处理“存在则更新，否则初始化”。
- 迭代器是集合操作的核心：`iter/iter_mut/into_iter` 分别对应借用/可变借用/消费。

