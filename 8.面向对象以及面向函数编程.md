# 第 8 章：面向对象与面向函数编程

本章会把 Rust 里两类“非常核心的抽象能力”串起来：

- **面向函数（Functional）**：闭包、迭代器、作为参数/返回值的函数。
- **面向对象（OOP）**：封装、（无继承的）组合、多态（trait + 动态分发/静态分发）。

---

## 1. 什么是闭包？闭包如何捕获外部变量

### 1.1 闭包的定义

**闭包（closure）**是一种“可以像函数一样被调用”的匿名函数值，但它额外拥有一个关键能力：

- **可以捕获（capture）其定义环境中的变量**。

闭包语法：

```rust
let add_one = |x: i32| x + 1;
println!("{}", add_one(10));
```

参数与返回类型通常可以由编译器推断：

```rust
let add = |a, b| a + b;
let sum = add(1, 2);
```

如果推断不出来（例如分支返回不同类型），就需要显式标注。

---

### 1.2 捕获外部变量：引用 vs 值（移动）

闭包会根据“它如何使用被捕获变量”自动选择捕获方式（编译器推断）：

1. **不可变借用**（`&T`）：只读访问。
2. **可变借用**（`&mut T`）：需要修改外部变量。
3. **移动（move）获取所有权**（`T`）：把变量所有权搬进闭包。

#### （1）捕获不可变引用

```rust
fn main() {
	let s = String::from("hello");

	let print = || {
		// 只读访问：捕获 &s
		println!("s = {s}");
	};

	print();
	print();

	// s 仍然可用
	println!("len = {}", s.len());
}
```

#### （2）捕获可变引用

```rust
fn main() {
	let mut count = 0;

	let mut inc = || {
		// 修改外部变量：捕获 &mut count
		count += 1;
		count
	};

	println!("{}", inc());
	println!("{}", inc());

	// 注意：只要闭包还“活着并可能被调用”，count 的可变借用规则会影响后续使用
	println!("count = {count}");
}
```

#### （3）捕获值：move 把所有权移动进闭包

有些场景必须把捕获变量移动到闭包里，比如：把闭包送到新线程执行（通常要求 `'static` 生命周期）。

```rust
use std::thread;

fn main() {
	let v = vec![1, 2, 3];

	let handle = thread::spawn(move || {
		// v 被 move 进闭包，线程安全地拥有 v 的所有权
		println!("v = {:?}", v);
	});

	handle.join().unwrap();
	// println!("{:?}", v); // 编译错误：v 的所有权已移动
}
```

##### 捕获“值类型”和“引用类型”的直观区别

- 像 `i32`、`bool` 这类实现了 `Copy` 的类型：即使闭包捕获了它，“移动”看起来也像复制，因为值会被拷贝一份（语义上仍然满足 move 规则）。
- 像 `String`、`Vec<T>` 这种拥有堆内存的类型：一旦 move 进闭包，外部变量就不能再用（除非把所有权再返回出来）。

```rust
fn main() {
	let x = 10; // Copy
	let s = String::from("hi");

	let c = move || {
		// x 会被 Copy 一份；s 会被 move
		println!("x = {x}, s = {s}");
	};

	c();
	println!("x still ok: {x}");
	// println!("s: {s}"); // 编译错误：s 已被 move
}
```

---

## 2. 闭包与函数的区别：Fn / FnMut / FnOnce

### 2.1 闭包与函数的关键差异

**函数（fn）**

- 有名字（或函数项），可直接作为函数指针使用。
- 不会捕获定义环境。
- 类型在编译期是“已命名且稳定”的（例如 `fn(i32) -> i32`）。

**闭包（closure）**

- 通常是匿名的，每个闭包表达式都有一个“编译器生成的独特类型”。
- 可以捕获定义环境的变量（引用/可变引用/移动）。
- 更灵活，但因此常需要用泛型约束（`F: Fn...`）或 trait object（`Box<dyn Fn...>`）来接收。

一个直观例子：闭包能捕获环境，而函数不能。

```rust
fn add_x(x: i32, y: i32) -> i32 {
	x + y
}

fn main() {
	let x = 5;
	let add = |y| x + y; // 捕获 x

	println!("{}", add(10));
	println!("{}", add_x(x, 10));
}
```

---

### 2.2 Fn / FnMut / FnOnce 的含义

Rust 用三个 trait 来描述闭包“被调用时需要什么能力”。它们不是你手写 `impl` 的那种 trait，而是编译器用来约束闭包行为的抽象：

- `FnOnce`：闭包**至少能调用一次**。
  - 调用时可能会**消耗（move）**捕获的变量。
  - 如果闭包捕获了某个变量并在调用时把它 move 出去，那么该闭包只能调用一次。
- `FnMut`：闭包可以调用多次，但调用时需要对捕获环境进行**可变访问**（相当于 `&mut self`）。
  - 典型：闭包内部修改了捕获变量。
- `Fn`：闭包可以调用多次，且调用时只需要**不可变访问**捕获环境（相当于 `&self`）。

它们的关系可以理解为：

$$Fn \subset FnMut \subset FnOnce$$

即：能当 `Fn` 用的闭包，一定也能当 `FnMut`、`FnOnce` 用；反过来不一定。

---

### 2.3 三种闭包类型示例

#### （1）Fn：只读捕获

```rust
fn call_twice<F>(f: F)
where
	F: Fn(),
{
	f();
	f();
}

fn main() {
	let s = String::from("hello");
	let f = || println!("{s}");
	call_twice(f);
}
```

#### （2）FnMut：修改捕获变量

```rust
fn call_twice_mut<F>(mut f: F)
where
	F: FnMut(),
{
	f();
	f();
}

fn main() {
	let mut n = 0;
	let mut f = || {
		n += 1;
		println!("n = {n}");
	};

	call_twice_mut(&mut f);
}
```

很多标准库 API 也会要求 `FnMut`，例如排序：

```rust
fn main() {
	let mut v = vec![3, 1, 2];
	let mut calls = 0;

	v.sort_by_key(|x| {
		calls += 1; // 因为会修改 calls，因此是 FnMut
		*x
	});

	println!("v = {:?}, calls = {calls}", v);
}
```

#### （3）FnOnce：消耗捕获变量（只能调用一次）

```rust
fn call_once<F>(f: F)
where
	F: FnOnce(),
{
	f();
}

fn main() {
	let s = String::from("bye");

	let consume = move || {
		// 把 s move 到 drop 里：调用会消耗捕获的 s
		drop(s);
	};

	call_once(consume);
	// consume(); // 编译错误：consume 已被 move/且闭包只能调用一次的语义
}
```

---

### 2.4 如何把闭包作为参数/返回值

#### （1）作为参数：用泛型 + trait bound

```rust
fn apply_to_10<F>(f: F) -> i32
where
	F: Fn(i32) -> i32,
{
	f(10)
}

fn main() {
	let x = 7;
	let add_x = |n| n + x;
	println!("{}", apply_to_10(add_x));
}
```

#### （2）作为返回值：常用 `impl Fn...`（静态分发）

```rust
fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
	move |n| n + x
}

fn main() {
	let add_3 = make_adder(3);
	println!("{}", add_3(10));
}
```

如果你需要在运行期返回“不同闭包类型之一”，就需要 trait object（例如 `Box<dyn Fn(i32) -> i32>`），因为每个闭包表达式的具体类型都不同。

---

### 2.5 迭代器与闭包：惰性求值、适配器与消费器

闭包通常会和 **迭代器（iterator）**一起使用：迭代器提供“如何遍历数据”的抽象，闭包提供“对每个元素做什么”。

#### 2.5.1 `iter` / `iter_mut` / `into_iter`

- `iter()`：遍历 **不可变引用**（`&T`）
- `iter_mut()`：遍历 **可变引用**（`&mut T`）
- `into_iter()`：遍历 **值本身**（`T`，会消耗集合的所有权）

```rust
fn main() {
	let v = vec![1, 2, 3];

	for x in v.iter() {
		println!("iter: {x}"); // x: &i32
	}

	// into_iter 会移动 v（Vec<i32>）
	for x in v.into_iter() {
		println!("into_iter: {x}"); // x: i32
	}

	// println!("{:?}", v); // 编译错误：v 已被移动
}
```

可变遍历（就地修改）：

```rust
fn main() {
	let mut v = vec![1, 2, 3];
	for x in v.iter_mut() {
		*x *= 10;
	}
	println!("{:?}", v);
}
```

#### 2.5.2 惰性（Lazy）：适配器不会立刻执行

迭代器的很多方法是 **适配器（adapter）**：它们会“构造一个新的迭代器”，但不会马上计算。

只有遇到 **消费器（consumer）** 时，链条才会真正跑起来，比如：`collect`、`sum`、`count`、`fold`、`for_each`。

```rust
fn main() {
	let v = vec![1, 2, 3, 4, 5];

	let it = v
		.iter()
		.map(|x| x * 2)      // 适配器：构造
		.filter(|x| x % 3 != 0); // 适配器：构造

	// 到这里为止都不会执行

	let result: Vec<i32> = it.collect(); // 消费器：真正执行
	println!("{:?}", result);
}
```

#### 2.5.3 常用链式写法：`map` / `filter` / `fold`

`map`：把每个元素映射为新值（通常要求闭包满足 `FnMut`）。

```rust
fn main() {
	let v = vec![1, 2, 3];
	let doubled: Vec<i32> = v.iter().map(|x| x * 2).collect();
	println!("{:?}", doubled);
}
```

`filter`：按条件筛选。

```rust
fn main() {
	let v = vec![1, 2, 3, 4, 5, 6];
	let evens: Vec<i32> = v.into_iter().filter(|x| x % 2 == 0).collect();
	println!("{:?}", evens);
}
```

`fold`：把一串元素“折叠”为一个值（非常通用的聚合）。

```rust
fn main() {
	let v = vec![1, 2, 3, 4];
	let sum = v.iter().fold(0, |acc, x| acc + x);
	println!("{sum}");
}
```

#### 2.5.4 迭代器链与性能：零成本抽象的直觉

初学者常担心链式调用会不会慢。Rust 的迭代器通常是“零成本抽象”的典型：

- 大量迭代器链会在编译期被内联与优化
- 你得到的往往是接近手写 `for` 循环的性能，同时代码更清晰

（当然，是否优化到位与具体代码形态、编译优化级别有关，但整体设计就是为了这点。）

---

## 3. 面向对象编程（OOP）的基本概念

Rust 不是传统意义“以类为中心”的语言，但 OOP 的很多思想仍然适用。先把常见概念说清楚：

### 3.1 类与对象

- **类（Class）**：数据（字段）+ 行为（方法）的模板。
- **对象（Object）**：类的实例。

Rust 没有 `class` 关键字；通常用 **`struct`/`enum` + `impl`** 来表达“数据 + 行为”。

### 3.2 封装（Encapsulation）

封装的目的：

- 隐藏内部实现细节
- 只暴露稳定的、受控的公开 API

在 Rust 中常通过：

- 模块边界（`mod`）
- 可见性（`pub`/私有）

来实现。

### 3.3 继承（Inheritance）

传统 OOP 中，继承常用于：

- 代码复用
- “is-a” 类型关系（子类是父类的一种）

Rust **没有类继承**。但 Rust 更偏向：

- **组合（composition）**：把一个类型放进另一个类型里复用能力。
- **trait + 默认方法**：共享行为。

### 3.4 多态（Polymorphism）

多态的核心：

> 同一种接口，对不同类型的值表现出不同的行为。

Rust 通过 trait 实现多态，有两种常见方式：

- **静态分发**：泛型 + trait bound（编译期决定调用哪个实现）。
- **动态分发**：trait object（运行期通过 vtable 决定调用哪个实现）。

---

## 4. Rust 中如何实现“面向对象”：结构体与枚举充当类的角色

### 4.1 用 struct + impl 表达“类”：字段 + 方法

```rust
#[derive(Debug)]
struct User {
	username: String,
	active: bool,
}

impl User {
	// 关联函数（类似静态方法 / 构造器）
	fn new(username: impl Into<String>) -> Self {
		Self {
			username: username.into(),
			active: true,
		}
	}

	// 方法（self / &self / &mut self）
	fn deactivate(&mut self) {
		self.active = false;
	}
}

fn main() {
	let mut u = User::new("alice");
	u.deactivate();
	println!("{u:?}");
}
```

这就是 Rust 中最常见的“类”的形态：数据在 `struct`，行为在 `impl`。

---

### 4.2 封装示例：用私有字段 + 公共方法维护不变量

下面这个例子演示“把内部数据藏起来，只提供受控操作”，并在每次修改后维护一个派生值（平均数）。

```rust
#[derive(Debug)]
pub struct AveragedCollection {
	list: Vec<i32>,
	average: f64,
}

impl AveragedCollection {
	pub fn new() -> Self {
		Self {
			list: Vec::new(),
			average: 0.0,
		}
	}

	pub fn add(&mut self, value: i32) {
		self.list.push(value);
		self.update_average();
	}

	pub fn remove(&mut self) -> Option<i32> {
		let result = self.list.pop();
		if result.is_some() {
			self.update_average();
		}
		result
	}

	pub fn average(&self) -> f64 {
		self.average
	}

	fn update_average(&mut self) {
		let sum: i32 = self.list.iter().sum();
		self.average = if self.list.is_empty() {
			0.0
		} else {
			sum as f64 / self.list.len() as f64
		};
	}
}

fn main() {
	let mut c = AveragedCollection::new();
	c.add(10);
	c.add(20);
	println!("avg = {}", c.average());
}
```

要点：

- `list` 与 `average` 不对外暴露（私有字段），外部无法绕过逻辑直接修改。
- `update_average` 是私有方法，用于维护结构体内部一致性。

---

### 4.3 用 enum 表达“对象的多种状态”：比继承更自然

枚举擅长表达“一个值在多个互斥状态之间切换”。这在很多 OOP 场景中能替代复杂的继承层次（尤其是状态机）。

```rust
#[derive(Debug, Clone, Copy)]
enum ConnectionState {
	Disconnected,
	Connecting,
	Connected,
}

impl ConnectionState {
	fn can_send(&self) -> bool {
		matches!(self, ConnectionState::Connected)
	}
}

fn main() {
	let st = ConnectionState::Connecting;
	println!("{st:?}, can_send = {}", st.can_send());
}
```

要点：

- `enum` 让“状态集合”在类型层面封闭（编译器可穷举检查）。
- 搭配 `match` 很容易写出清晰的状态转移逻辑。

---

## 5. trait 是什么？trait 如何实现多态

### 5.1 trait 的定义与实现

trait 可以理解为：

- 一组方法签名（接口）
- 可选的默认实现

```rust
trait Summary {
	fn summarize(&self) -> String;

	fn summarize_short(&self) -> String {
		"(read more...)".to_string()
	}
}

struct News {
	title: String,
	author: String,
}

impl Summary for News {
	fn summarize(&self) -> String {
		format!("{} by {}", self.title, self.author)
	}
}

fn main() {
	let n = News {
		title: "Rust 1.xx released".to_string(),
		author: "Ferris".to_string(),
	};

	println!("{}", n.summarize());
	println!("{}", n.summarize_short());
}
```

---

### 5.2 trait bound：用泛型实现“静态分发多态”

静态分发的特点：

- 编译期确定具体类型与具体实现
- 通常性能最好（会单态化：为每个具体类型生成专门代码）
- 但一个容器里通常只能放一种具体类型（因为 `Vec<T>` 的 `T` 必须统一）

```rust
trait Draw {
	fn draw(&self);
}

struct Button {
	label: String,
}

impl Draw for Button {
	fn draw(&self) {
		println!("[Button: {}]", self.label);
	}
}

fn render<T: Draw>(component: &T) {
	component.draw();
}

fn main() {
	let b = Button {
		label: "OK".to_string(),
	};
	render(&b);
}
```

`where` 语法可以让约束更清晰：

```rust
fn render_all<T>(components: &[T])
where
	T: Draw,
{
	for c in components {
		c.draw();
	}
}
```

---

### 5.3 trait object：用动态分发实现“运行期多态”

动态分发的特点：

- 运行期通过 vtable 决定调用哪个实现
- 允许在同一个集合中放入**不同具体类型**（只要它们都实现同一个 trait）
- 通常会有一点点间接调用成本

```rust
trait Draw {
	fn draw(&self);
}

struct Button {
	label: String,
}

impl Draw for Button {
	fn draw(&self) {
		println!("[Button: {}]", self.label);
	}
}

struct SelectBox {
	options: Vec<String>,
}

impl Draw for SelectBox {
	fn draw(&self) {
		println!("[SelectBox: {} options]", self.options.len());
	}
}

struct Screen {
	components: Vec<Box<dyn Draw>>,
}

impl Screen {
	fn run(&self) {
		for c in &self.components {
			c.draw();
		}
	}
}

fn main() {
	let screen = Screen {
		components: vec![
			Box::new(Button {
				label: "Submit".to_string(),
			}),
			Box::new(SelectBox {
				options: vec!["A".to_string(), "B".to_string()],
			}),
		],
	};

	screen.run();
}
```

这里的 `Box<dyn Draw>` 就是 trait object：

- `dyn Draw` 表示“某个实现了 Draw 的具体类型，但我在编译期不关心它是谁”。
- `Box` 提供堆分配与稳定大小（trait object 需要“胖指针”来携带 vtable 信息）。

---

### 5.4 什么时候选泛型，什么时候选 trait object？

- 选 **泛型 + trait bound（静态分发）**：
  - 你更关心性能/内联
  - 你的容器/数据结构是同构的（全是同一种类型）
  - API 使用者希望在编译期获得更强的类型信息
- 选 **trait object（动态分发）**：
  - 你需要“同一个容器里放多种组件/插件”
  - 你想做运行期扩展（例如 UI 组件、策略模式、插件系统）

补充：并不是所有 trait 都能做成 trait object（涉及“对象安全”规则）。一个经验判断：如果 trait 方法需要返回 `Self`、或带有泛型参数等，往往就不能直接做成 `dyn Trait`。

---

## 小结

- 闭包的核心是“像函数一样调用 + 能捕获环境”。捕获方式由使用方式推断：`&T`、`&mut T`、`move T`。
- `Fn`/`FnMut`/`FnOnce` 描述闭包调用时对环境的需求，理解它们能读懂大量标准库 API 的签名。
- 迭代器与闭包常搭配使用：适配器惰性构造，消费器触发执行，链式写法清晰且通常性能很好。
- Rust 没有类继承，但能用 `struct/enum + impl`、可见性控制、组合、trait 来完成 OOP 的核心目标。
- 多态通过 trait 实现：泛型是静态分发；`dyn Trait` 是动态分发。
