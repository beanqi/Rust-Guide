# 第二章 Rust 基础语法

------

## 1. Variables and Mutability（变量与可变性）

### 1.1 默认不可变：`let`

Rust 里变量**默认不可变（immutable）**：一旦绑定了值，就不能再把它改成别的值。这样做能让代码更容易推理，也利于安全与并发场景。

```rust
fn main() {
    let x = 5;
    // x = 6; // ❌ 编译错误：不能给不可变变量二次赋值
    println!("x = {x}");
}
```

> 这和很多语言（默认可变）不同：Rust 会“逼你明确表达意图”。

------

### 1.2 显式可变：`let mut`

如果你确实需要修改值，在变量名前加 `mut`。

```rust
fn main() {
    let mut x = 5;
    println!("x = {x}");
    x = 6;
    println!("x = {x}");
}
```

**经验提示**

- `mut` 的价值不只是“能改”，更是给读代码的人一个信号：这个变量会变。

------

### 1.3 常量：`const`

`const` 用来声明常量：

- 可以在任何作用域（包括全局）声明
- **必须显式写类型**
- 只能用**常量表达式**初始化（编译期可计算）

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

fn main() {
    println!("{THREE_HOURS_IN_SECONDS}");
}
```

------

### 1.4 Shadowing（遮蔽）：同名 `let` 重新绑定

Rust 允许用同名变量“重新声明”来遮蔽旧值：后面的 `x` 会遮住前面的 `x`，直到作用域结束。

```rust
fn main() {
    let x = 5;
    let x = x + 1; // ✅ 新的 x，遮蔽旧的 x

    {
        let x = x * 2; // ✅ 内层作用域再遮蔽
        println!("inner x = {x}");
    }

    println!("outer x = {x}");
}
```

**`mut` vs shadowing（很关键）**

- `mut`：同一个绑定，值变，但**类型不能变**
- shadowing：新绑定，可以“换类型”（常用于 `trim/parse` 这类转换）

```rust
fn main() {
    let s = " 42 ";
    let s = s.trim();        // &str  去掉前后空格
    let s: i32 = s.parse().unwrap(); // i32   类型转换
    println!("{s}");
}
```

------

## 2. Data Types（数据类型）

Rust 是**静态类型**语言：编译期必须知道所有变量类型。通常编译器能推断，但某些场景需要你写类型标注，例如把字符串 `parse()` 成数字时。

```rust
fn main() {
    let n: u32 = "42".parse().expect("not a number");
    println!("{n}");
}
```

------

### 2.1 标量类型（Scalar Types）

Rust 的四大标量类型：**整数、浮点、布尔、字符**。

#### 2.1.1 整数（Integers）

- 有符号：`i8/i16/i32/i64/i128/isize`
- 无符号：`u8/u16/u32/u64/u128/usize`
- 默认整数类型通常是 `i32`
- 字面量支持 `_` 分隔、以及 `0xff / 0o77 / 0b...` 等形式，还能加后缀如 `57u8`

```rust
fn main() {
    let a = 1_000_000i32;
    let b = 0xffu8;
    let c = 0b1111_0000u8;
    println!("{a} {b} {c}");
}
```

**整数溢出（Overflow）**

- Debug 构建：溢出会触发运行时 panic
- Release 构建：通常按二进制补码“回绕”（wrapping）
- 可用 `wrapping_* / checked_* / overflowing_* / saturating_*` 系列方法显式处理

```rust
fn main() {
    let x: u8 = 255;
    let y = x.wrapping_add(1); // 0
    let z = x.checked_add(1);  // None
    println!("{y} {:?}", z);
}
```

#### 2.1.2 浮点（Floating-Point）

`f32` / `f64`，默认 `f64`；遵循 IEEE-754。

```rust
fn main() {
    let x = 2.0;      // f64
    let y: f32 = 3.0; // f32
    println!("{x} {y}");
}
```

#### 2.1.3 布尔（Boolean）

`bool`：`true/false`，常用于条件判断。

```rust
fn main() {
    let ok: bool = true;
    if ok {
        println!("ok");
    }
}
```

#### 2.1.4 字符（`char`）

- 用**单引号**表示：`'a'`
- `char` 是 4 字节，表示一个 Unicode 标量值（可表示中文、emoji 等）

```rust
fn main() {
    let c1 = 'z';
    let c2 = '中';
    let c3 = '😺';
    println!("{c1} {c2} {c3}");
}
```

------

### 2.2 复合类型（Compound Types）

#### 2.2.1 元组（Tuple）

元组可装不同类型，**长度固定**；支持解构与下标访问。

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    let (a, b, c) = tup;  // 解构
    println!("{a} {b} {c}");

    println!("{}", tup.1); // 下标访问：6.4
}
```

> 空元组 `()` 叫 **unit**，常见于“不返回任何值”的场景。

#### 2.2.2 数组（Array）

数组：

- 元素类型必须相同
- **长度固定**
- 常用于栈上固定大小数据；更灵活的可变长集合是 `Vec`（后面章节讲）

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    let b: [i32; 5] = [1, 2, 3, 4, 5];
    let c = [3; 5]; // 等价于 [3,3,3,3,3]
    println!("{} {} {}", a[0], b[1], c[4]);
}
```

**越界访问会 panic**
数组索引越界是运行时错误（会直接 panic），这属于 Rust 的安全策略之一。

------

### 2.3 字符串：`String` 与 `&str`

Rust 里最常见的“字符串”其实有两种形态：

- `&str`：**字符串切片**（borrowed view），通常指向一段已经存在的 UTF-8 字节序列
- `String`：**拥有所有权**的、可增长的字符串类型（数据在堆上）

这两者的关系非常像：`Vec<T>` vs `&[T]`。

#### 2.3.1 `&str`：字符串切片（最常见的输入类型）

字符串字面量（例如 `"hello"`）的类型是 `&'static str`：它指向编译进程序的只读数据，生命周期为 `'static`。

```rust
fn main() {
    let s: &str = "hello";
    println!("{s}");
}
```

你也可以从 `String` 上借用出 `&str`：

```rust
fn main() {
    let s = String::from("hello");
    let view: &str = &s; // ✅ &String 会自动解引用成 &str（Deref coercion）
    println!("{view}");
}
```

经验：很多函数参数更偏向写成 `&str`，这样既能接收字符串字面量，也能接收 `String` 的借用。

#### 2.3.2 `String`：堆上可变、可增长

当你需要“拼接 / 修改 / 动态构造”字符串时，一般使用 `String`。

```rust
fn main() {
    let mut s = String::new();
    s.push_str("hello");
    s.push(' ');
    s.push_str("rust");
    println!("{s}");
}
```

常见创建方式：

```rust
fn main() {
    let a = String::from("hello");
    let b = "hello".to_string();
    println!("{a} {b}");
}
```

#### 2.3.3 拼接与格式化：`+` vs `format!`

- `+` 会“拿走”左边 `String` 的所有权（更准确地说：`String + &str -> String`），所以左边一般不能再用
- `format!` 不会拿走参数所有权（更像 `println!` 生成一个新的 `String`）

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = String::from("rust");

    let s3 = s1 + " " + &s2; // s1 被 move 了，后面不能再用
    let s4 = format!("{} {}", s3, s2); // 不会 move s3/s2
    println!("{s4}");
}
```

#### 2.3.4 不能用下标索引字符串（因为 UTF-8）

Rust 的 `String` / `str` 是 UTF-8 编码，直接用 `s[0]` 取“第一个字符”在语义上并不总是成立（一个“字符”可能是多个字节）。因此 Rust **禁止**字符串下标索引。

如果你要按“字符”遍历：

```rust
fn main() {
    for ch in "中a😺".chars() {
        println!("{ch}");
    }
}
```

如果你要按“字节”处理：

```rust
fn main() {
    for b in "hello".bytes() {
        print!("{b} ");
    }
}
```

> 字符串切片（例如 `&s[0..2]`）需要落在 UTF-8 字符边界上，否则会 panic；初学阶段尽量用 `chars()` 更省心。

------

## 3. Functions（函数）

### 3.1 基本形式与命名风格

用 `fn` 定义函数；Rust 习惯用 **snake_case** 命名。函数定义位置不重要，只要作用域可见即可。

```rust
fn main() {
    hello_world();
}

fn hello_world() {
    println!("Hello, world!");
}
```

------

### 3.2 参数（Parameters）

参数需要写类型；调用时传入的是实参（argument），但日常经常混用术语。

```rust
fn main() {
    print_sum(3, 4);
}

fn print_sum(x: i32, y: i32) {
    println!("sum = {}", x + y);
}
```

------

### 3.3 语句 vs 表达式（Statements vs Expressions）

Rust 是“表达式导向”语言：

- **语句（statement）**执行动作，不返回值
- **表达式（expression）**会计算并产生值
- 代码块 `{ ... }` 也是表达式
- 一个表达式末尾加上 `;` 会把它变成语句（不再返回值）

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1 // 没有分号：这是表达式，块返回 4
    };
    println!("y = {y}");
}
```

常见坑：`let x = (let y = 6);` 这种写法会报错，因为 `let y = 6` 是语句，不产生值。

------

### 3.4 返回值（Return Values）

- 返回类型写在 `->` 后面
- 通常用函数体最后一个表达式作为返回值（不写 `return`）
- 也可以用 `return` 提前返回

```rust
fn five() -> i32 {
    5
}

fn plus_one(x: i32) -> i32 {
    x + 1
}

fn main() {
    println!("{}", five());
    println!("{}", plus_one(41));
}
```

------

## 4. Comments（注释）

Rust 常用 `//` 行注释；多行就每行写一个 `//`。也可以写在行尾，但更推荐写在被注释代码的上方。

```rust
fn main() {
    // 我们在这里做一些解释
    let lucky_number = 7; // 行尾注释也可以
    println!("{lucky_number}");
}
```

> Rust 还有文档注释（`///`、`//!`），用于生成 API 文档，本书后面章节会展开。

------

## 5. Control Flow（控制流）

### 5.1 `if` 表达式

#### 5.1.1 条件必须是 `bool`

Rust 不会把整数等类型自动转成布尔值（不像 JS/Ruby）。条件必须是 `bool`，否则编译报错。

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("small");
    } else {
        println!("big");
    }
}
```

#### 5.1.2 `else if`

多分支用 `else if`，但分支太多建议用 `match`（后面章节会讲）。

因为 `if` 是表达式，可以直接赋值给变量；但 **if/else 两个分支的结果类型必须一致**。

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };
    println!("{number}");
}
```

------

### 5.2 循环（Loops）：`loop` / `while` / `for`

Rust 提供三种循环。

#### 5.2.1 `loop`：无限循环 + `break/continue`

`loop` 会一直执行，直到 `break`。

```rust
fn main() {
    let mut i = 0;
    loop {
        i += 1;
        if i == 3 {
            continue; // 跳过本次剩余代码
        }
        if i == 5 {
            break; // 退出循环
        }
        println!("i = {i}");
    }
}
```

**`break` 还能带值：让 `loop` 变成“可返回的表达式”**

```rust
fn main() {
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2; // result = 20
        }
    };
    println!("result = {result}");
}
```

**循环标签（Loop Labels）**
嵌套循环时，`break/continue` 默认作用于最内层；用标签可指定要跳出哪一层。

```rust
fn main() {
    let mut x = 0;

    'outer: loop {
        x += 1;
        let mut y = 3;

        loop {
            y -= 1;
            if y == 0 {
                break; // 只退出内层
            }
            if x == 2 {
                break 'outer; // 退出外层
            }
        }
    }
    println!("done");
}
```

#### 5.2.2 `while`：条件循环

当条件为真就执行，为假就退出。

```rust
fn main() {
    let mut n = 3;
    while n != 0 {
        println!("{n}!");
        n -= 1;
    }
    println!("LIFTOFF!!!");
}
```

#### 5.2.3 `for`：遍历集合/范围（最常用）

用 `while + index` 遍历数组既容易写错也可能更慢；Rust 更推荐 `for`，更安全、更简洁。

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    for element in a {
        println!("{element}");
    }
}
```

用范围（Range）循环次数，并配合 `rev()` 倒序：

```rust
fn main() {
    for n in (1..4).rev() {
        println!("{n}!");
    }
    println!("LIFTOFF!!!");
}
```

------

