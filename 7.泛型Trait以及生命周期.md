# 第七章 泛型 Trait 以及生命周期

本章把 Rust 中三个“看起来最抽象、但工程里最常用”的能力一次讲透：

- **泛型（Generics）**：写一次代码，适配多种类型。
- **Trait**：抽象“能力/行为”，并用它约束泛型。
- **生命周期（Lifetimes）**：让“引用”在编译期被证明永远有效。

它们的关系可以用一句话概括：

> 泛型负责“类型参数化”，Trait 负责“能力约束”，生命周期负责“引用有效性”。

参考阅读：Rust Book 第 10 章（你提供的链接）。

------

## 1. 泛型（Generics）：为什么需要、在哪里用、性能如何

### 1.1 什么是泛型？

泛型就是“把类型当参数传进来”。你可以先把它理解为：

- 让函数/结构体/枚举/方法可以处理多种类型
- 同时保持类型安全（编译期检查）

典型动机：你想写一个 `max`，既能比较 `i32`，又能比较 `f64`，还想保持零成本抽象。

### 1.2 在函数中使用泛型

最经典的例子：找 slice 里的最大元素。

```rust
fn largest<T: PartialOrd>(list: &[T]) -> &T {
	let mut largest = &list[0];
	for item in list {
		if item > largest {
			largest = item;
		}
	}
	largest
}

fn main() {
	let nums = vec![34, 50, 25, 100, 65];
	println!("{}", largest(&nums));

	let chars = vec!['y', 'm', 'a', 'q'];
	println!("{}", largest(&chars));
}
```

要点：

- `T` 是类型参数
- `T: PartialOrd` 是 **Trait Bound**（后面会专门讲），表示 `T` 必须可比较
- 返回 `&T`，不会 move 元素

注意：这个实现**假定切片非空**。如果你想让它更稳健，可以返回 `Option<&T>`：

```rust
fn largest<T: PartialOrd>(list: &[T]) -> Option<&T> {
	if list.is_empty() {
		return None;
	}
	let mut largest = &list[0];
	for item in list {
		if item > largest {
			largest = item;
		}
	}
	Some(largest)
}
```

### 1.3 在结构体中使用泛型

```rust
#[derive(Debug)]
struct Point<T> {
	x: T,
	y: T,
}

fn main() {
	let p1 = Point { x: 1, y: 2 };
	let p2 = Point { x: 1.5, y: 2.0 };
	println!("p1={p1:?}, p2={p2:?}");
}
```

结构体也可以混合多种类型参数：

```rust
#[derive(Debug)]
struct Pair<A, B> {
	a: A,
	b: B,
}

fn main() {
	let p = Pair { a: 1, b: "hello" };
	println!("{p:?}");
}
```

### 1.4 在枚举中使用泛型

你已经见过最常用的两个：

- `Option<T>`
- `Result<T, E>`

它们的思想就是“枚举里装泛型类型”。

```rust
fn main() {
	let x: Option<i32> = Some(10);
	let y: Option<&str> = None;
	println!("{x:?} {y:?}");

	let ok: Result<i32, &str> = Ok(42);
	let err: Result<i32, &str> = Err("bad");
	println!("{ok:?} {err:?}");
}
```

### 1.5 在方法（impl）中使用泛型

#### 为泛型结构体写方法

```rust
#[derive(Debug)]
struct Point<T> {
	x: T,
	y: T,
}

impl<T> Point<T> {
	fn new(x: T, y: T) -> Self {
		Self { x, y }
	}
}

fn main() {
	let p = Point::new(1, 2);
	println!("{p:?}");
}
```

#### 只对“某些具体类型”实现方法

```rust
struct Point<T> {
	x: T,
	y: T,
}

impl Point<f64> {
	fn distance_from_origin(&self) -> f64 {
		(self.x * self.x + self.y * self.y).sqrt()
	}
}

fn main() {
	let p = Point { x: 3.0, y: 4.0 };
	println!("{}", p.distance_from_origin());
}
```

这叫 **特化到具体类型的 impl**（不是 unstable 的 specialization feature）。

### 1.6 泛型的性能：编译期单态化（monomorphization）

Rust 的泛型是“零成本抽象”的关键之一：绝大多数情况下，泛型不会带来运行期分发开销。

原因：**编译器在编译期把泛型展开成具体类型版本**，这叫单态化。

示意图（概念图）：

```
源代码（泛型）:
  fn id<T>(x: T) -> T { x }

编译期单态化（生成多个具体版本）:
  fn id_i32(x: i32) -> i32 { x }
  fn id_string(x: String) -> String { x }
```

结论：

- **速度**：接近手写的具体类型版本（静态分发）
- **代价**：可能增加编译产物体积（每种 `T` 生成一份代码）

------

## 2. Trait：抽象能力、Trait Bound、与 Trait Object

### 2.1 Trait 是什么？

Trait 可以理解为“接口/能力集合”：

- 规定某种类型必须提供哪些方法（行为）
- 允许泛型对类型提出能力要求（约束）
- 支持静态分发（泛型 + bound）与动态分发（trait object）

### 2.2 定义与实现 Trait

```rust
trait Summary {
	fn summarize(&self) -> String;
}

struct NewsArticle {
	headline: String,
	author: String,
}

impl Summary for NewsArticle {
	fn summarize(&self) -> String {
		format!("{} (by {})", self.headline, self.author)
	}
}

fn main() {
	let a = NewsArticle {
		headline: "Rust 1.xx released".to_string(),
		author: "Ferris".to_string(),
	};
	println!("{}", a.summarize());
}
```

#### 默认方法（default method）

Trait 可以提供默认实现：

```rust
trait Summary {
	fn summarize(&self) -> String {
		"(read more...)".to_string()
	}
}

struct Tweet {
	username: String,
	content: String,
}

impl Summary for Tweet {
	// 不写 summarize，就用默认实现
}

fn main() {
	let t = Tweet { username: "u".to_string(), content: "hi".to_string() };
	println!("{}", t.summarize());
}
```

### 2.3 Trait Bound：用 Trait 约束泛型

泛型解决“类型参数化”，Trait Bound 解决“这个类型必须会什么”。

#### 写法 1：`impl Trait`（更简洁）

```rust
trait Summary {
	fn summarize(&self) -> String;
}

fn notify(item: &impl Summary) {
	println!("Breaking: {}", item.summarize());
}
```

#### 写法 2：显式泛型 + bound（更灵活）

```rust
fn notify<T: Summary>(item: &T) {
	println!("Breaking: {}", item.summarize());
}
```

两者在“单参数”情况下很像，但显式泛型更适合表达：

- 多个参数必须是同一类型：

```rust
trait Summary {
	fn summarize(&self) -> String;
}

fn notify_same<T: Summary>(a: &T, b: &T) {
	println!("a={}, b={}", a.summarize(), b.summarize());
}
```

如果写成 `fn notify_same(a: &impl Summary, b: &impl Summary)`，它允许 `a`、`b` 是不同类型（只要都实现了 Summary）。

#### 多重约束：`+` 与 `where`

```rust
use std::fmt::Display;

fn print_and_len<T: Display + AsRef<str>>(x: T) {
	println!("{} (len={})", x, x.as_ref().len());
}
```

当约束很长时推荐 `where`：

```rust
use std::fmt::Display;

fn do_stuff<T, U>(t: T, u: U)
where
	T: Display + Clone,
	U: Display,
{
	println!("t={t}, u={u}");
	let _t2 = t.clone();
}
```

### 2.4 Trait 与 Generics 的关系

- **Generics**：让“形状”可复用（T/U/…）
- **Trait**：让“能力”可复用（行为抽象）
- **Trait Bound**：把二者连接起来：你写泛型，但同时要求能力

一句话：

> “泛型不等于多态”，多态来自“泛型 + 约束（Trait Bound）”或“Trait Object”。

### 2.5 `impl Trait` 与 Trait Object（`dyn Trait`）

这是工程里最容易混淆的一块。

#### 2.5.1 `&impl Trait`：静态分发（编译期确定类型）

```rust
use std::fmt::Display;

fn show(x: &impl Display) {
	println!("{x}");
}

fn main() {
	let a = 1;
	let b = "hi";
	show(&a);
	show(&b);
}
```

关键点：

- 对每次调用，编译器都知道具体类型
- 通常能内联，性能好
- 但容器里想混放不同类型就不方便（因为泛型容器要求元素同一具体类型）

#### 2.5.2 `&dyn Trait`：动态分发（运行期 vtable 调用）

Trait Object 允许你“把不同具体类型当作同一个 trait 来用”。

```rust
use std::fmt::Display;

fn show_dyn(x: &dyn Display) {
	println!("{x}");
}

fn main() {
	let a = 1;
	let b = "hi";
	show_dyn(&a);
	show_dyn(&b);
}
```

`&dyn Display` 在内存里大致是一个“胖指针”（概念图）：

```
&dyn Trait  ~=  (data_ptr, vtable_ptr)

data_ptr  -> 指向具体值
vtable_ptr-> 指向方法表（函数指针等元信息）
```

对比总结：

- `&impl Trait`：静态分发，通常更快
- `&dyn Trait`：动态分发，能把不同类型统一对待（异质集合/插件式架构）

#### 2.5.3 典型使用场景：异质集合（heterogeneous collection）

假设你有 UI 组件：按钮、文本框……它们类型不同，但都能 `draw`。

```rust
trait Draw {
	fn draw(&self);
}

struct Button;
struct TextBox;

impl Draw for Button {
	fn draw(&self) { println!("draw button"); }
}

impl Draw for TextBox {
	fn draw(&self) { println!("draw textbox"); }
}

fn main() {
	let widgets: Vec<Box<dyn Draw>> = vec![Box::new(Button), Box::new(TextBox)];
	for w in &widgets {
		w.draw();
	}
}
```

如果用泛型 `Vec<T>`，`T` 必须是同一个具体类型，无法同时放 Button 和 TextBox。

#### 2.5.4 什么时候不要用 `dyn Trait`？

经验法则：

- 能用泛型 + trait bound（静态分发）就优先用它
- 当你需要“运行期选择具体类型”或“异质集合/插件系统”时再用 `dyn Trait`

------

## 3. 生命周期（Lifetimes）：引用为什么需要它（选读）

### 3.1 生命周期解决的问题：避免悬垂引用

Rust 的引用必须永远有效。生命周期系统本质上是：

- 编译器对“引用能活多久”的推理与证明
- 当推理不够时，需要你用生命周期参数把关系讲清楚

先看一个典型错误（悬垂引用）：

```rust
fn main() {
	let r;
	{
		let x = 10;
		r = &x;
	}
	// println!("{r}"); // ❌ x 已离开作用域，r 会悬垂
}
```

Rust 宁可编译期拒绝，也不允许运行期踩内存。

### 3.2 生命周期标注：描述“引用之间的关系”

生命周期标注**不是**在说“引用活多久”（那由作用域决定），而是在说：

> “输入引用与输出引用的生命周期之间是什么关系”。

最经典的例子：返回更长的那个 `&str`。

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
	if x.len() >= y.len() { x } else { y }
}

fn main() {
	let s1 = String::from("abcd");
	let s2 = "xyz";
	let r = longest(s1.as_str(), s2);
	println!("{r}");
}
```

读法：

- `<'a>` 声明一个生命周期参数
- `&'a str` 表示“至少活到 `'a` 这段时间的引用”
- 返回值也标 `'a`，表示返回的引用要和输入的两者共享同一个 `'a` 约束

你可以把它想象成“返回值的生命周期不会超过输入中更短的那个”。

示意图（概念图）：

```
时间轴:  |--------------------------->

s1:      |-------------------|
s2:      |----------|

返回引用:|----------|   (被更短的那个限制)
```

### 3.3 生命周期省略规则（lifetime elision rules）

很多时候你不写生命周期，编译器也能推断，这是因为有省略规则。常见规则（面向函数签名的心智模型）：

1) **每个引用参数都有自己的生命周期参数**（如果没写，编译器先“假想”有）

2) **如果只有一个引用输入参数，那么输出引用（如果有）与它同生命周期**

3) **如果有多个引用输入参数，且其中一个是 `&self` 或 `&mut self`，那么输出引用与 `self` 同生命周期**

举例：

```rust
fn first_word(s: &str) -> &str {
	let bytes = s.as_bytes();
	for (i, &b) in bytes.iter().enumerate() {
		if b == b' ' {
			return &s[0..i];
		}
	}
	s
}
```

这里没写 `<'a>`，但能工作，因为：

- 只有一个引用输入 `s: &str`
- 输出 `&str` 自动与 `s` 绑定

注意：`longest(x, y)` 这种“多个输入引用、输出引用来自其中之一”的情况，通常无法省略。

### 3.4 在结构体中使用生命周期：结构体持有引用

当结构体字段是引用时，你必须标注它引用数据的生命周期：

```rust
#[derive(Debug)]
struct ImportantExcerpt<'a> {
	part: &'a str,
}

fn main() {
	let s = String::from("Call me Ishmael. Some years ago...");
	let first_sentence = s.split('.').next().unwrap();
	let excerpt = ImportantExcerpt { part: first_sentence };
	println!("{excerpt:?}");
}
```

这表达了：`ImportantExcerpt` 这个值的存活时间，不能超过 `part` 引用的那段字符串。

### 3.5 方法签名里的生命周期：`&self` 触发省略规则

```rust
struct ImportantExcerpt<'a> {
	part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
	fn level(&self) -> i32 {
		3
	}

	fn announce_and_return_part(&self, msg: &str) -> &str {
		println!("Attention: {msg}");
		self.part
	}
}
```

`announce_and_return_part(&self, msg: &str) -> &str` 没写生命周期依然成立：

- 输入有多个引用（`&self` 和 `&str`）
- 根据省略规则：输出引用绑定到 `self` 的生命周期

### 3.6 `'static`：全程序生命周期（谨慎使用）

`'static` 表示引用在整个程序运行期间都有效。典型来源：

- 字符串字面量：`"hello"` 的类型是 `&'static str`

```rust
fn main() {
	let s: &'static str = "hello";
	println!("{s}");
}
```

经验：

- 不要把“编译不过”当成理由去强行用 `'static`
- 更常见的正确修复是：调整所有权（用 `String`）、调整作用域、或补齐生命周期关系

------

## 4. 三者结合：写出灵活且安全的工程代码（选读）

这一节的目标是：看到复杂签名不慌，能拆开读懂，并能在项目里用对。

### 4.1 如何读复杂签名：从外到内拆

看一个常见的“组合体”：

```rust
fn choose<'a, T, F>(items: &'a [T], pick: F) -> Option<&'a T>
where
	F: Fn(&T) -> bool,
{
	for item in items {
		if pick(item) {
			return Some(item);
		}
	}
	None
}

fn main() {
	let v = vec![10, 20, 30, 40];
	let r = choose(&v, |x| *x >= 30);
	println!("{r:?}");
}
```

拆解读法：

- `items: &'a [T]`：输入是对 slice 的借用，元素类型为 `T`
- `-> Option<&'a T>`：返回 slice 内某个元素的引用，因此输出生命周期必须与 `items` 绑定
- `F: Fn(&T) -> bool`：第二个参数是一个闭包/函数，能检查元素

这种函数在工程里非常常见：**输入借用一段数据，返回其中元素的借用**。

### 4.2 “泛型容器 + Trait Bound”：做通用算法/工具

例子：把任何可迭代的东西打印出来（工程里用于调试非常常见）。

```rust
use std::fmt::Display;

fn print_all<I, T>(iter: I)
where
	I: IntoIterator<Item = T>,
	T: Display,
{
	for x in iter {
		println!("{x}");
	}
}

fn main() {
	print_all(vec![1, 2, 3]);
	print_all(["a", "b", "c"]);
}
```

要点：

- `IntoIterator` 让函数既能吃 `Vec<T>`，也能吃数组、切片迭代器等
- `T: Display` 把“打印能力”作为约束

### 4.3 “Trait Object”：插件式/异质集合的工程写法

当你需要“运行期决定用哪个实现”，或者“集合里放不同类型”，用 trait object。

典型模式：定义一个 trait 作为扩展点，然后在运行期组装一组实现。

```rust
trait Processor {
	fn name(&self) -> &'static str;
	fn process(&self, input: &str) -> String;
}

struct Upper;
impl Processor for Upper {
	fn name(&self) -> &'static str { "upper" }
	fn process(&self, input: &str) -> String { input.to_uppercase() }
}

struct Trim;
impl Processor for Trim {
	fn name(&self) -> &'static str { "trim" }
	fn process(&self, input: &str) -> String { input.trim().to_string() }
}

fn run_pipeline(steps: &[Box<dyn Processor>], input: &str) -> String {
	let mut s = input.to_string();
	for step in steps {
		s = step.process(&s);
	}
	s
}

fn main() {
	let steps: Vec<Box<dyn Processor>> = vec![Box::new(Trim), Box::new(Upper)];
	let out = run_pipeline(&steps, "  hello rust  ");
	println!("{out}");
}
```

这类模式在：日志处理、规则引擎、序列化中间层、可插拔策略等场景很常见。

### 4.4 生命周期 + Trait Bound：返回“借用视图”

很多 API 想做到：

- 输入：借用一段数据
- 输出：借用其中一部分（避免拷贝）

例如：从任意能提供 `&str` 视图的东西里挑“最长的视图”。

```rust
fn longest_view<'a, T>(a: &'a T, b: &'a T) -> &'a str
where
	T: AsRef<str>,
{
	let sa = a.as_ref();
	let sb = b.as_ref();
	if sa.len() >= sb.len() { sa } else { sb }
}

fn main() {
	let s1 = String::from("abcd");
	let s2 = String::from("xyz");
	let r = longest_view(&s1, &s2);
	println!("{r}");
}
```

注意：这里返回的是 `&str`，而不是 `&T`。关键在于 `AsRef<str>` 让我们能得到借用视图。

### 4.5 常见“坑位清单”（你在项目里会反复遇到）

1) **返回引用时，先问自己：引用来自哪里？**
	- 来自参数：多半要用生命周期参数
	- 来自函数内部临时值：几乎一定不行（临时值会被释放）

2) **容器里要混放不同类型？优先考虑 trait object**
	- `Vec<T>`：同质
	- `Vec<Box<dyn Trait>>`：异质

3) **需要极致性能/可内联？优先泛型 + bound**
	- 静态分发 + 单态化
	- 避免动态分发与堆分配（如果你不需要它们）

4) **读不懂签名时，用“谁借用谁、输出借用谁”来画关系图**
	- 尤其是 `Option<&'a T>`、`Result<&'a T, E>` 这类返回

------

## 本章小结

- 泛型让代码复用：函数/结构体/枚举/方法都能参数化类型。
- Rust 泛型在编译期会单态化：大多是静态分发、零运行期开销，但可能增加代码体积。
- Trait 抽象“能力”，Trait Bound 把能力约束施加到泛型上。
- `&impl Trait` 通常是静态分发；`&dyn Trait` 是 trait object（胖指针 + vtable），适合异质集合与运行期多态。
- 生命周期保证引用永远有效；标注的核心是“描述输入引用与输出引用的关系”；理解省略规则能减少大量标注。
